'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SceneConfiguration holds the layers added to the Viewer and their respective configuration.
 * Layer's config is a simply JS object so it can store any kind of value.
 */

/*
    Layers are "something" that produce a visual result.
    They're composed of an 'id' and an 'update' function. As they are plain JS objects they can have as much
    properties as the user needs.

    Layer can be chained. Connected layers will only get called if their ascendant returns something to update.
    A chain link stores a layer and optionnal next links.

    Some examples. If a user wants to:
      - display a globe: he'll add a [geometry] layer, configured to produce ellispoid-based tiles
      - display imagery from a WMTS server: she'll attach a [imagery] layer to the globe layer. This [imagery] layer will
        download and apply image from the server.
      - display WFS building: he'll add a [feature] layer, querying WFS server and instanciating 3d model
      - change building color based on current time: she'll add a [processing] layer, attached to the 3d model layer
*/

function SceneConfiguration() {
    // layerChains stored the first layer links of each layer chain
    this.layerChains = [];

    // layers state (visibility, opacity)
    this.layersState = {};
}

// Helper func to call fn() on each layer
function _traverseLayers(fn, link) {
    fn(link.layer);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(link.nextLayerLinks), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var lk = _step.value;

            _traverseLayers(fn, lk);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

// Helper func to call fn() on each link
function _traverseLayerLinks(fn, link) {
    fn(link);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = (0, _getIterator3.default)(link.nextLayerLinks), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var lk = _step2.value;

            _traverseLayerLinks(fn, lk);
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }
}

/**
 * Add a layer to the scene.
 * If parentLayerId is a valid layer id, the layer will be attached to parentLayerId
 */
SceneConfiguration.prototype.attach = function attach(layer, parentLayerId) {
    if (layer.id in this.layersState) {
        throw new Error('Layer id ' + layer.id + ' already added');
    }
    if (!layer.update || !layer.update) {
        throw new Error('Invalid layer ' + layer.id + ' definition: (missing update and/or id property');
    }

    if (parentLayerId === undefined) {
        this.layerChains.push({ layer: layer, nextLayerLinks: [] });
    } else if (!(parentLayerId in this.layersState)) {
        throw new Error('Cannot attach layer ' + layer.id + ' to non-added layer ' + parentLayerId);
    } else {
        // traverse stages and attach as a child of parentLayerId
        this.traverseLayerLinks(function (link) {
            if (link.layer.id === parentLayerId) {
                link.nextLayerLinks.push({ layer: layer, nextLayerLinks: [] });
            }
        });
    }

    this.layersState[layer.id] = {};
};

SceneConfiguration.prototype.detach = function detach(id) {
    if (this.layersState[id]) {
        for (var i = 0; i < this.layerChains.length; i++) {
            var link = this.layerChains[i];
            if (link.layer.id === id) {
                this.layerChains.splice(i, 1);
                break;
            }
        }
        this.traverseLayerLinks(function (link) {
            for (var _i = 0; _i < link.nextLayerLinks.length; _i++) {
                if (link.nextLayerLinks[_i].layer.id === id) {
                    link.nextLayerLinks.splice(_i, 1);
                }
            }
        });

        delete this.layersState[id];
        return true;
    }
    return false;
};

SceneConfiguration.prototype.traverseLayers = function traverseLayers(fn) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = (0, _getIterator3.default)(this.layerChains), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var firstLink = _step3.value;

            _traverseLayers(fn, firstLink);
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }
};

SceneConfiguration.prototype.traverseLayerLinks = function traverseLayerLinks(fn) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = (0, _getIterator3.default)(this.layerChains), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var firstLink = _step4.value;

            _traverseLayerLinks(fn, firstLink);
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }
};

SceneConfiguration.prototype.setLayerAttribute = function setLayerAttribute(id, attribute, value) {
    if (this.layersState[id]) {
        this.layersState[id][attribute] = value;
    } else {
        // eslint-disable-next-line no-console
        console.warn('Invalid layer id \'' + id + '\'. Ignoring attribute definition');
    }
};

SceneConfiguration.prototype.getLayerAttribute = function getLayerAttribute(id, attribute) {
    return this.layersState[id][attribute];
};

SceneConfiguration.prototype.getLayers = function getLayers(filter) {
    var _this = this;

    var result = [];
    this.traverseLayers(function (layer) {
        if (!filter || filter(layer, _this.layersState[layer.id])) {
            result.push(layer);
        }
    });
    return result;
};

// The following code is specific to color layers when using LayeredMaterial, so it probably doesn't
// belong tto this file.
SceneConfiguration.prototype.moveLayerToIndex = function moveLayerToIndex(id, newIndex) {
    if (this.layersState[id]) {
        var oldIndex = this.layersState[id].sequence;
        for (var i in this.layersState) {
            if (Object.prototype.hasOwnProperty.call(this.layersState, i)) {
                var state = this.layersState[i];
                if (state.sequence === newIndex) {
                    state.sequence = oldIndex;
                    this.layersState[id].sequence = newIndex;
                    break;
                }
            }
        }
    }
};

SceneConfiguration.prototype.moveLayerDown = function moveLayerDown(id) {
    if (this.layersState[id] && this.layersState[id].sequence > 0) {
        this.moveLayerToIndex(id, this.layersState[id].sequence - 1);
    }
};

SceneConfiguration.prototype.moveLayerUp = function moveLayerUp(id) {
    if (this.layersState[id] && this.layersState[id].sequence) {
        this.moveLayerToIndex(id, this.layersState[id].sequence + 1);
    }
};

SceneConfiguration.prototype.getColorLayersIdOrderedBySequence = function getColorLayersIdOrderedBySequence() {
    var _this2 = this;

    var seq = this.getLayers(function (l) {
        return _this2.getLayerAttribute(l.id, 'type') === 'color';
    }).map(function (l) {
        return l.id;
    });
    seq.sort(function (a, b) {
        return _this2.layersState[a].sequence - _this2.layersState[b].sequence;
    });
    return seq;
};

exports.default = SceneConfiguration;