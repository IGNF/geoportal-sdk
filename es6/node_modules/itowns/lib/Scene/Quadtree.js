'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _Layer = require('./Layer');

var _Layer2 = _interopRequireDefault(_Layer);

var _Scheduler = require('../Core/Commander/Scheduler');

var _Scheduler2 = _interopRequireDefault(_Scheduler);

var _NodeMesh = require('../Renderer/NodeMesh');

var _NodeMesh2 = _interopRequireDefault(_NodeMesh);

var _BoundingBox = require('./BoundingBox');

var _BoundingBox2 = _interopRequireDefault(_BoundingBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Generated On: 2015-10-5
 * Class: Quadtree
 * Description: Structure de données spatiales possedant jusqu'à 4 Nodes
 */

/**
 *
 * @param {type} Layer
 * @param {type} Quad
 * @returns {Quadtree_L13.Quadtree}
 */
function Quadtree(type, schemeTile, link) {
    _Layer2.default.call(this);

    this.type = type;
    this.scheduler = (0, _Scheduler2.default)();
    this.link = link;
    this.schemeTile = schemeTile;
    this.tileType = type;
    this.minLevel = 2;
    this.maxLevel = 17;
    var rootNode = new _NodeMesh2.default();

    rootNode.frustumCulled = false;
    rootNode.material.visible = false;

    rootNode.link = this.link;

    rootNode.changeState = function changeState() {
        return true;
    };

    this.add(rootNode);
}

Quadtree.prototype = (0, _create2.default)(_Layer2.default.prototype);

Quadtree.prototype.constructor = Quadtree;

Quadtree.prototype.init = function init(geometryLayer, lightingLayer) {
    var rootNode = this.children[0];
    var promises = [];

    for (var i = 0; i < this.schemeTile.rootCount(); i++) {
        promises.push(this.requestNewTile(geometryLayer, this.schemeTile.getRoot(i), rootNode, lightingLayer));
    }
    return _promise2.default.all(promises);
};

Quadtree.prototype.northWest = function northWest(node) {
    return node.children[0];
};

Quadtree.prototype.northEast = function northEast(node) {
    return node.children[1];
};

Quadtree.prototype.southWest = function southWest(node) {
    return node.children[2];
};

Quadtree.prototype.southEast = function southEast(node) {
    return node.children[3];
};

Quadtree.prototype.requestNewTile = function requestNewTile(geometryLayer, bbox, parent, lightingLayer) {
    var command = {
        /* mandatory */
        requester: parent,
        layer: geometryLayer,
        priority: 10000,
        /* specific params */
        bbox: bbox,
        type: this.type,
        level: 0,
        light: lightingLayer
    };

    return this.scheduler.execute(command);
};

Quadtree.prototype.canSubdivideNode = function canSubdivideNode(node) {
    return node.level < this.maxLevel;
};

/**
 * @documentation: returns bounding boxes of a node's quadtree subdivision
 * @param {type} node
 * @returns {Array} an array of four bounding boxex
 */
Quadtree.prototype.subdivideNode = function subdivideNode(node) {
    if (node.pendingSubdivision || !this.canSubdivideNode(node)) {
        return [];
    }

    var bbox = node.bbox;
    var center = bbox.center();

    var northWest = new _BoundingBox2.default(bbox.crs(), bbox.west(), center._values[0], center._values[1], bbox.north());
    var northEast = new _BoundingBox2.default(bbox.crs(), center._values[0], bbox.east(), center._values[1], bbox.north());
    var southWest = new _BoundingBox2.default(bbox.crs(), bbox.west(), center._values[0], bbox.south(), center._values[1]);
    var southEast = new _BoundingBox2.default(bbox.crs(), center._values[0], bbox.east(), bbox.south(), center._values[1]);

    // scheme tiles store their coordinates in radians internally,
    // so we need to fix the new bboxes as well
    var result = [northWest, northEast, southWest, southEast];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(result), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _bbox = _step.value;

            _bbox.minCoordinate._internalStorageUnit = node.bbox.minCoordinate._internalStorageUnit;
            _bbox.maxCoordinate._internalStorageUnit = node.bbox.minCoordinate._internalStorageUnit;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return result;
};

Quadtree.prototype.traverse = function traverse(foo, node) {
    if (foo(node)) {
        for (var i = 0; i < node.children.length; i++) {
            this.traverse(foo, node.children[i]);
        }
    }
};

Quadtree.prototype.getTile = function getTile(coordinate) {
    var point = { x: coordinate.longitude(), y: coordinate.latitude() };

    var gT = function gT(tile) {
        var inside = tile.bbox ? tile.bbox.isInside(point) : true;

        if (tile.children.length === 0 && inside) {
            point.tile = tile;
        }

        // TODO: Fix error verify if this is correct
        if (inside) {
            point.parent = tile.parent;
        }

        return inside;
    };

    this.traverse(gT, this.children[0]);

    if (point.tile === undefined) {
        return point.parent;
    } else {
        return point.tile;
    }
};

exports.default = Quadtree;