'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AnimatedExpression = exports.Animation = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FRAMERATE = 60;
var FRAME_DURATION = 1000 / FRAMERATE;
// if is true console.log are enabled to sniff animation'state
var debugAnimation = false;

// player statut
var PLAYER_STATE = {
    // player is stopped
    STOP: 0,
    // player plays animation
    PLAY: 1,
    // player is at the end of an animation
    END: 2,
    // player is paused
    PAUSE: 3
};

var debugMsg = ['Stop', 'Play', 'End', 'Pause'];

// if debugAnimation is true console.log are enabled to sniff animation'state
var _DEBUG = null;

if (debugAnimation) {
    _DEBUG = function DEBUG(message, animation) {
        if (animation) {
            // eslint-disable-next-line no-console
            console.info('Animation ', message, ' : ', animation.name);
        }
    };
} else {
    _DEBUG = function _DEBUG() {};
}

// Private functions
// stop timer and re-init parameter
var resetTimer = function resetTimer(player) {
    if (player.id) {
        clearInterval(player.id);
        player.id = undefined;
    }
    if (player.waitTimer) {
        clearInterval(player.waitTimer);
        player.waitTimer = undefined;
    }
    player.keyframe = 0;
};

// finish animation and re-init parameter
var finishAnimation = function finishAnimation(player) {
    resetTimer(player);
    player.animation = null;
    if (player.resolve) {
        player.resolve();
        player.resolve = null;
        player.promise = null;
    }
};

var setPlayerState = function setPlayerState(player, state) {
    player.state = state;
    _DEBUG(debugMsg[state], player.animation);
};

var frameEvent = new CustomEvent('frameAnimation');
var stopEvent = new CustomEvent('stopAnimation');
var endEvent = new CustomEvent('endAnimation');

/**
 * AnimationPlayer
 * It can play, pause or stop Animation or AnimationExpression (See below).
 * AnimationPlayer is needed to use Animation or AnimationExpression
 * AnimationPlayer emits events :
 *       - for each animation's frame;
 *       - when Animation is stopped
 *       - when Animation is ending
 */

var AnimationPlayer = function () {
    function AnimationPlayer(dom) {
        (0, _classCallCheck3.default)(this, AnimationPlayer);

        this.dom = dom;
        this.id = null;
        this.keyframe = 0;
        this.animation = null;
        this.resolve = null;
        this.promise = null;
        this.state = PLAYER_STATE.STOP;
        this.waitTimer = null;
    }

    (0, _createClass3.default)(AnimationPlayer, [{
        key: 'isPlaying',
        value: function isPlaying() {
            return this.state === PLAYER_STATE.PLAY;
        }
    }, {
        key: 'isStopped',
        value: function isStopped() {
            return this.state === PLAYER_STATE.STOP;
        }
    }, {
        key: 'isEnded',
        value: function isEnded() {
            return this.state === PLAYER_STATE.END;
        }

        // Public functions

        /**
         * { Start animation }
         * this function play one animation.
         * If another animation is playing, it's stopped and the new animation is played
         * @param      {Animation} The animation to play
         * @return     {Promise}  Promise is resolved when animation is stopped or finished
         */

    }, {
        key: 'play',
        value: function play(animation) {
            var _this = this;

            this.animation = animation;
            setPlayerState(this, PLAYER_STATE.PLAY);
            resetTimer(this);
            this.id = setInterval(this.frame.bind(this), FRAME_DURATION);
            this.promise = new _promise2.default(function (r) {
                _this.resolve = r;
            });
            return this.promise;
        }

        /**
         * { The animation is played after a number of frames }
         *
         * @param      {Animation}  animation    The animation to play
         * @param      {Number}  waitingTime  The waiting time before start animation (time in frame)
         */

    }, {
        key: 'playLater',
        value: function playLater(animation, waitingFrame) {
            var _this2 = this;

            this.resolveWait = null;
            var promise = new _promise2.default(function (r) {
                _this2.resolveWait = r;
            });
            var timew = Math.floor(FRAME_DURATION * waitingFrame);
            window.clearInterval(this.waitTimer);
            this.waitTimer = window.setTimeout(function () {
                _this2.play(animation).then(function () {
                    return _this2.resolveWait();
                });
            }, timew);
            return promise;
        }

        /**
         * { Stop current animation }
         *
         * @return  {Promise}  Promise is resolved when animation is stopped or finished
         */

    }, {
        key: 'stop',
        value: function stop() {
            setPlayerState(this, PLAYER_STATE.STOP);
            finishAnimation(this);
            this.dom.dispatchEvent(stopEvent);
            // needed to return promise to wait sync
            return _promise2.default.resolve();
        }

        /**
         * { this function is executed with each frame }
         */

    }, {
        key: 'frame',
        value: function frame() {
            if (this.keyframe < this.animation.duration) {
                if (this.animation.animate) {
                    this.animation.animate(this.keyframe);
                }
                this.keyframe++;
                this.dom.dispatchEvent(frameEvent);
            } else {
                setPlayerState(this, PLAYER_STATE.END);
                finishAnimation(this);
                this.dom.dispatchEvent(endEvent);
            }
        }
    }]);
    return AnimationPlayer;
}();

/**
 * { Animation }
 * Animation is play by the AnimationPlayer during the time of duration
 * During playback, the AnimationPlayer emits event for each frame
 * Animation is used to execute a callback to each frame
 * @class      Animation
 * @param      {Number}  duration  The animation's duration in number of frames. FRAMERATE is number of frames in one seconde.
 * @param      {String}  name      The animation's name. It's used for debug message.
 */


var Animation = function Animation(params) {
    (0, _classCallCheck3.default)(this, Animation);

    this.duration = params.duration || FRAMERATE;
    this.name = params.name;
};

/**
 * { function_description }
 * AnimatedExpression is play by the AnimationPlayer during the time of duration
 * During playback, the AnimationPlayer emits event for each frame and
 * it applies expression on root.
 * AnimatedExpression is used to change object's values for each frame
 * @class      AnimatedExpression (name)
 * @param      {Number}   duration    The animation's duration in number of frames. FRAMERATE is number of frames in one seconde.
 * @param      {Object}   root        The root is the object in scene to animate
 * @param      {Function} expression  The expression is function applied to root with each frame
 * @param      {String}   name        The animation's name. It's used for debug message
  */

var AnimatedExpression = function (_Animation) {
    (0, _inherits3.default)(AnimatedExpression, _Animation);

    function AnimatedExpression(params) {
        (0, _classCallCheck3.default)(this, AnimatedExpression);

        var _this3 = (0, _possibleConstructorReturn3.default)(this, (AnimatedExpression.__proto__ || (0, _getPrototypeOf2.default)(AnimatedExpression)).call(this, params));

        _this3.root = params.root;
        _this3.expression = params.expression;
        return _this3;
    }

    (0, _createClass3.default)(AnimatedExpression, [{
        key: 'animate',
        value: function animate(keyFrame) {
            this.expression(this.root, keyFrame / this.duration);
        }
    }]);
    return AnimatedExpression;
}(Animation);

exports.Animation = Animation;
exports.AnimatedExpression = AnimatedExpression;
exports.default = AnimationPlayer;