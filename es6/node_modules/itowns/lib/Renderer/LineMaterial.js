'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _c3DEngine = require('./c3DEngine');

var _c3DEngine2 = _interopRequireDefault(_c3DEngine);

var _BasicMaterial = require('./BasicMaterial');

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _Fetcher = require('../Core/Commander/Providers/Fetcher');

var _Fetcher2 = _interopRequireDefault(_Fetcher);

var _LineVS = "attribute vec3  position;\nattribute vec3  previous;\nattribute vec3  next;\n\nattribute float side;\nattribute float width;\nattribute vec2 uv;\n\nuniform bool useRTC;\n\nuniform mat4 mVPMatRTC;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nuniform float THICKNESS;  // the thickness of the line in pixels\nuniform float MITER_LIMIT;    // 1.0: always miter, -1.0: never miter, 0.75: default\nuniform vec2 WIN_SCALE;  // the size of the viewport in pixels\n\nuniform float opacity;\nuniform bool sizeAttenuation;\nuniform vec3 color;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPosition;\n\n\nvec2 screen_space(vec4 vertex)\n{\n    return vec2( vertex.xy / vertex.w ) * WIN_SCALE;\n}\n\nvec2 fix( vec4 i, float aspect ) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n\nvoid main() {\n\n    float aspect = WIN_SCALE.x / WIN_SCALE.y;\n    float pixelWidthRatio = 1. / (WIN_SCALE.x * projectionMatrix[0][0]);\n    vColor = vec4( color, opacity );\n    vUV = uv;\n\n    mat4 projModelViewMatrix = useRTC ? mVPMatRTC : projectionMatrix * modelViewMatrix;\n\n    vec4 projectedPrePoint = projModelViewMatrix * vec4(previous,1.0);\n    vec4 projectedCurPoint = projModelViewMatrix * vec4(position,1.0);\n    vec4 projectedNextPoint = projModelViewMatrix * vec4(next,1.0);\n\n    #ifdef USE_LOGDEPTHBUF\n\n        #ifndef USE_LOGDEPTHBUF_EXT\n\n            projectedPrePoint.z = (projectedPrePoint.z - 1.0) * projectedPrePoint.w;\n            projectedCurPoint.z = (projectedCurPoint.z - 1.0) * projectedCurPoint.w;\n            projectedNextPoint.z = (projectedNextPoint.z - 1.0) * projectedNextPoint.w;\n\n        #else\n\n            projectedPrePoint.z = log2(max( EPSILON, projectedPrePoint.w + 1.0 )) * logDepthBufFC;\n            projectedCurPoint.z = log2(max( EPSILON, projectedCurPoint.w + 1.0 )) * logDepthBufFC;\n            projectedNextPoint.z = log2(max( EPSILON, projectedNextPoint.w + 1.0 )) * logDepthBufFC;\n\n        #endif\n\n    #endif\n\n    vec2 previousScreen = fix( projectedPrePoint,aspect );  // start of previous segment\n    vec2 currentScreen = fix( projectedCurPoint ,aspect);   // end of previous segment, start of current segment\n    vec2 nextScreen = fix( projectedNextPoint ,aspect); // end of current segment, start of next segment\n\n    float pixelWidth = projectedCurPoint.w * pixelWidthRatio;\n    float w = 1.8*pixelWidth * THICKNESS * width;\n\n    if(sizeAttenuation) {\n            w = 1.8 * THICKNESS * width;\n    }\n\n    //starting point uses (next - current)\n    vec2 dir = vec2(0.0);\n    //float len = THICKNESS;\n\n    if (currentScreen == previousScreen) {\n            dir = normalize(nextScreen - currentScreen);\n    }\n    //ending point uses (current - previous)\n    else if (currentScreen == nextScreen) {\n           dir = normalize(currentScreen - previousScreen);\n    }\n    //somewhere in middle, needs a join\n    else {\n             //get directions from (C - B) and (B - A)\n             vec2 dirA = normalize((currentScreen - previousScreen));\n             if (MITER_LIMIT == 1.0) {\n                    vec2 dirB = normalize(nextScreen - currentScreen);\n                    //now compute the miter join normal and length\n                    vec2 tangent = normalize(dirA + dirB);\n                    vec2 perp = vec2(-dirA.y, dirA.x);\n                    vec2 miter = vec2(-tangent.y, tangent.x);\n                    dir = tangent;\n                    //len = THICKNESS / dot(miter, perp);\n                    //w = clamp( w / dot( miter, perp ), 0., 4. * THICKNESS * width );\n            } else {\n                 dir = dirA;\n            }\n    }\n\n    vec2 normal = vec2(-dir.y, dir.x);\n    normal.x /= aspect;\n    normal *= 0.5 * w;\n    //normal *= len/2.0;\n\n    vec4 offset = vec4(normal*side, 0.0, 1.0);\n    projectedCurPoint.xy += offset.xy;\n\n    vPosition    = ( modelViewMatrix * vec4( position, 1. ) ).xyz;\n    gl_Position  = projectedCurPoint;\n    gl_PointSize = 10.0;\n\n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n}";

var _LineVS2 = _interopRequireDefault(_LineVS);

var _LineFS = "\nuniform sampler2D texture;\nuniform bool useTexture;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPosition;\n\nvoid main() {\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n       gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n\tvec4 c = vColor;\n\n    if(useTexture) {\n        c = texture2D( texture, vUV );\n    }\n\n    gl_FragColor = c;\n}";

var _LineFS2 = _interopRequireDefault(_LineFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LineMaterial = function LineMaterial(options) {
    _BasicMaterial2.default.call(this);

    if (options === undefined) {
        throw new Error('options is required');
    }

    this.fragmentShader = this.fragmentShaderHeader + _LineFS2.default;
    this.vertexShader = this.vertexShaderHeader + _LineVS2.default;

    this.wireframe = false;

    var texture = options.texture ? _Fetcher2.default.texture(options.texture) : undefined;

    this.uniforms.THICKNESS = { value: options.linewidth };
    this.uniforms.MITER_LIMIT = { value: 1.0 };
    this.uniforms.WIN_SCALE = { value: (0, _c3DEngine2.default)().viewerDiv.size };
    if (texture) {
        this.uniforms.texture = { value: texture };
    }
    this.uniforms.useTexture = { value: texture ? options.useTexture : false };
    this.uniforms.opacity = { value: options.opacity };
    this.uniforms.sizeAttenuation = { value: options.sizeAttenuation };
    this.uniforms.color = { value: options.color };
    this.transparent = true;
}; /*
    * To change this license header, choose License Headers in Project Properties.
    * To change this template file, choose Tools | Templates
    * and open the template in the editor.
    */

LineMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
LineMaterial.prototype.constructor = LineMaterial;

exports.default = LineMaterial;