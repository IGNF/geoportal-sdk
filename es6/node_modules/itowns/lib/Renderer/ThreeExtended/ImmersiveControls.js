'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _sign = require('babel-runtime/core-js/math/sign');

var _sign2 = _interopRequireDefault(_sign);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _MainLoop = require('../../Core/MainLoop');

var _AnimationPlayer = require('../../Core/AnimationPlayer');

var _AnimationPlayer2 = _interopRequireDefault(_AnimationPlayer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_FOV = 40;
var Verbose = false;
// Note: we could use existing three.js controls (like https://github.com/mrdoob/three.js/blob/dev/examples/js/controls/FirstPersonControls.js)
// but including these controls in itowns allows use to integrate them tightly with itowns.
// Especially the existing controls are expecting a continuous update loop while we have a pausable one (so our controls use .notifyChange when needed)

function onMouseDown(event) {
    //    console.log(event);
    // event.preventDefault();
    this._isUserInteracting = true;

    this._onMouseDownMouseX = event.clientX;
    this._onMouseDownMouseY = event.clientY;
    this._onMouseDownPhi = this._phi;
    this._onMouseDownTheta = this._theta;
}

/*
// WORK IN PROGRESS ON DOUBLE CLICK -> MOUSE PICK
function onDoubleClick(event) {
    if (Verbose) {
        // eslint-disable-next-line no-console
        console.log('IMMERSIVE CONTROL DOUBLE CLICK', event);
    }
    const mouse = new THREE.Vector2((event.clientX / event.screenX) * 2 - 1, -(event.clientY / event.screenY) * 2 + 1);
    const raycaster = new THREE.Raycaster();

    raycaster.setFromCamera(mouse, this.camera);
    const intersects = raycaster.intersectObjects(this.view.scene.children, true);
    // eslint-disable-next-line no-console
    console.log('INTERSECT OBJECTS : ', intersects);
    // for (var i = 0; i < intersects.length; i++) {
    //     console.log(intersects[i]);
    // }
}
*/
function onMouseMove(event) {
    if (this._isUserInteracting === true) {
        // WORK IN PROGRESS ON PAN
        // if (this.shiftPressed) {
        //     // PAN MOVES
        //     // TODO : Stop move when mouse move ends.
        //     if (this.panMoveX) this.moves.delete(this.panMoveX);
        //     const deltaX = this._onMouseDownMouseX - event.clientX;
        //     if (deltaX < 0) {
        //         this.panMoveX = { method: 'translateX', sign: -10 };
        //     } else {
        //         this.panMoveX = { method: 'translateX', sign: 10 };
        //     }
        //     this.moves.add(this.panMoveX);
        //     // It doesn't work with 'translateY'
        // } else {
        //     // RETATION MOVES
        var fovCorrection = this.camera.fov / MAX_FOV; // 1 at MAX_FOV
        this._phi = -1 * (this._onMouseDownMouseX - event.clientX) * 0.13 * fovCorrection + this._onMouseDownPhi;
        this._theta = (event.clientY - this._onMouseDownMouseY) * 0.13 * fovCorrection + this._onMouseDownTheta;
        // }
        this.view.notifyChange(false);
    }
}
function onMouseWheel(event) {
    var delta = 0;
    var mult = 100;
    if (event.wheelDelta !== undefined) {
        delta = -event.wheelDelta * mult;
        // Firefox
    } else if (event.detail !== undefined) {
        delta = event.detail * mult;
    }

    this.camera.fov = THREE.Math.clamp(this.camera.fov + (0, _sign2.default)(delta), 10, 180);

    this.camera.updateProjectionMatrix();
    this.view.notifyChange(true, this.camera);
}

function onMouseUp() {
    this._isUserInteracting = false;
    if (this.panMoveX) this.moves.delete(this.panMoveX);
}

function onKeyUp(e) {
    var move = MOVEMENTS[e.keyCode];
    if (move) {
        this.moves.delete(move);
        this.view.notifyChange(true);
        e.preventDefault();
    }

    // key Shift
    if (e.keyCode == 16) {
        this.shiftPressed = false;
    }
}

function onKeyDown(e) {
    // key Z
    if (e.keyCode == 90) {
        this.moveCameraToNextPano();
    }

    // key A
    if (e.keyCode == 65) {
        this.setCameraToCurrentPano();
    }

    // key E
    if (e.keyCode == 69) {
        this.nextLayer();
        this.moveCameraToNextPano();
    }

    // key Shift
    if (e.keyCode == 16) {
        this.shiftPressed = true;
    }

    var move = MOVEMENTS[e.keyCode];
    if (move) {
        this.moves.add(move);
        this.view.notifyChange(false);
        e.preventDefault();
    }
}

var MOVEMENTS = {
    38: { method: 'translateZ', sign: -1 }, // FORWARD: up key
    40: { method: 'translateZ', sign: 1 }, // BACKWARD: down key
    37: { method: 'translateX', sign: -1 }, // STRAFE_LEFT: left key
    39: { method: 'translateX', sign: 1 }, // STRAFE_RIGHT: right key
    33: { method: 'translateY', sign: 1 }, // UP: PageUp key
    34: { method: 'translateY', sign: -1 } // DOWN: PageDown key
};

// Expression used to damp camera's moves
function moveCameraExp(root, progress) {
    // const dampingProgress = 1 - Math.pow((1 - (Math.sin((progress - 0.5) * Math.PI) * 0.5 + 0.5)), 2);
    // root.camera.position.lerpVectors(root.positionFrom, root.positionTo, dampingProgress);
    root.camera.position.lerpVectors(root.positionFrom, root.positionTo, progress);
}

function update2() {
    this.view.notifyChange(true, this.view);
}

function getPanoPosition(layer, panoIndex) {
    if (panoIndex >= layer.orientedImages.length) return;

    var P = layer.orientedImages[panoIndex].coordinates;
    var cameraPosition = new THREE.Vector3().set(P._values[0], P._values[1], P._values[2]);
    return { position: cameraPosition };
}

function getNextPano(layer) {
    var panoIndex = (layer.currentPano + 1) % layer.orientedImages.length;
    return getPanoPosition(layer, panoIndex);
}

function getCurrentPano(layer) {
    return getPanoPosition(layer, layer.currentPano);
}

var ImmersiveControls = function (_THREE$EventDispatche) {
    (0, _inherits3.default)(ImmersiveControls, _THREE$EventDispatche);

    // Animations
    function ImmersiveControls(view) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, _classCallCheck3.default)(this, ImmersiveControls);

        var _this = (0, _possibleConstructorReturn3.default)(this, (ImmersiveControls.__proto__ || (0, _getPrototypeOf2.default)(ImmersiveControls)).call(this));

        _this.camera = view.camera.camera3D;
        _this.view = view;

        _this.player = new _AnimationPlayer2.default();
        _this.animationMoveCamera = new _AnimationPlayer.AnimatedExpression({ duration: 5, root: _this, expression: moveCameraExp, name: 'Move camera' });

        _this.layers = [];
        _this.currentLayerIndex = 0;

        _this.moves = new _set2.default();
        _this.moveSpeed = options.moveSpeed || 1; // backward or forward move speed in m/s
        _this._isUserInteracting = false;
        _this._onMouseDownMouseX = 0;
        _this._onMouseDownMouseY = 0;
        _this._onMouseDownPhi = 0;
        _this._onMouseDownTheta = 0;

        _this.objectCam = new THREE.Object3D();
        _this.view.scene.add(_this.objectCam);
        // this.axis = new THREE.AxisHelper( 50 );
        _this.axis = new THREE.Object3D();
        _this.objectCam.add(_this.axis);

        _this.camera.fov = 75;
        // this.axis.rotation.reorder('ZYX');
        // this._theta = THREE.Math.radToDeg(this.axis.rotation.x);
        // this._phi = THREE.Math.radToDeg(this.axis.rotation.z);
        // this.updateAngles();

        var lookAtPosition = _this.camera.position.clone().multiplyScalar(1.1);
        _this.setCameraOnPano(_this.camera.position.clone(), lookAtPosition);

        _this._handlerMouseDown = onMouseDown.bind(_this);
        _this._handlerMouseMove = onMouseMove.bind(_this);
        _this._handlerMouseUp = onMouseUp.bind(_this);
        // this._handlerDoubleClick = onDoubleClick.bind(this);
        _this._handlerKeyUp = onKeyUp.bind(_this);
        _this._handlerKeyDown = onKeyDown.bind(_this);
        _this._handlerMouseWheel = onMouseWheel.bind(_this);
        _this._handlerAnimation = update2.bind(_this);

        _this.domElement = view.mainLoop.gfxEngine.renderer.domElement;
        _this.domElement.addEventListener('mousedown', _this._handlerMouseDown, false);
        _this.domElement.addEventListener('mousemove', _this._handlerMouseMove, false);
        _this.domElement.addEventListener('mouseup', _this._handlerMouseUp, false);
        // this.domElement.addEventListener('dblclick', this._handlerDoubleClick, false);
        _this.domElement.addEventListener('keyup', _this._handlerKeyUp, true);
        _this.domElement.addEventListener('keydown', _this._handlerKeyDown, true);
        _this.domElement.addEventListener('mousewheel', _this._handlerMouseWheel, false);
        _this.domElement.addEventListener('DOMMouseScroll', _this._handlerMouseWheel, false); // firefox
        _this.player.addEventListener('animation-frame', _this._handlerAnimation);
        _this.view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, _this.update.bind(_this));
        return _this;
    }

    (0, _createClass3.default)(ImmersiveControls, [{
        key: 'dispose',
        value: function dispose() {
            this.domElement.removeEventListener('mousedown', this._handlerMouseDown, false);
            this.domElement.removeEventListener('mousemove', this._handlerMouseMove, false);
            this.domElement.removeEventListener('mouseup', this._handlerMouseUp, false);
            this.domElement.removeEventListener('dblclick', this._handlerDoubleClick, false);

            this.domElement.removeEventListener('keyup', this._handlerKeyUp, true);
            this.domElement.removeEventListener('keydown', this._handlerKeyDown, true);

            this.domElement.removeEventListener('mousewheel', this._handlerMouseWheel, false);
            this.domElement.removeEventListener('DOMMouseScroll', this._handlerMouseWheel, false);

            this.player.removeEventListener('animation-frame', this._handlerAnimation);

            this.view.removeFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, this);
        }
    }, {
        key: 'addLayer',
        value: function addLayer(layer) {
            this.layers.push(layer);
            this.currentLayer = layer;
            this.currentLayerIndex = this.layers.length - 1;
        }
    }, {
        key: 'nextLayer',
        value: function nextLayer() {
            this.currentLayerIndex = (this.currentLayerIndex + 1) % this.layers.length;
            this.currentLayer = this.layers[this.currentLayerIndex];
        }
    }, {
        key: 'isUserInteracting',
        value: function isUserInteracting() {
            return this.moves.size !== 0;
        }
    }, {
        key: 'setCameraToCurrentPano',
        value: function setCameraToCurrentPano() {
            var nextPanoPosition = getNextPano(this.currentLayer).position;
            var currentPanoPosition = getCurrentPano(this.currentLayer).position;
            this.setCameraOnPano(currentPanoPosition, nextPanoPosition);
            // this.view.wgs84TileLayer.visible = !this.view.wgs84TileLayer.visible;
        }
    }, {
        key: 'moveCameraTo',
        value: function moveCameraTo(positionTo) {
            this.positionFrom = this.camera.position.clone();
            this.positionTo = positionTo;
            this.player.play(this.animationMoveCamera);
        }
    }, {
        key: 'moveCameraToNextPano',
        value: function moveCameraToNextPano() {
            this.moveCameraTo(getNextPano(this.currentLayer).position);
        }
    }, {
        key: 'updateAngles',
        value: function updateAngles() {
            // get angles from axis (axis rotation move as mouse move, in the plan tangent to the surface of the globe)
            this.axis.rotation.order = 'ZYX';
            this.axis.rotation.x = THREE.Math.degToRad(this._theta);
            this.axis.rotation.z = THREE.Math.degToRad(this._phi); // + Math.PI;
            this.axis.updateMatrixWorld();

            var rotMatrix = new THREE.Matrix4();
            rotMatrix.multiplyMatrices(this.objectCam.matrix, this.axis.matrix);
            this.camera.rotation.setFromRotationMatrix(rotMatrix);

            this.view.notifyChange(true, this.view);
        }
    }, {
        key: 'setCameraOnPano',
        value: function setCameraOnPano(positionPano, nextPanoPosition) {
            // move camObject on the surface of the globe
            this.objectCam.position.copy(positionPano);
            this.objectCam.lookAt(this.objectCam.position.clone().multiplyScalar(1.1));
            this.objectCam.updateMatrixWorld();

            // rotate axis to look at next pano
            var nextPanoLocal = this.objectCam.worldToLocal(nextPanoPosition);
            this.axis.lookAt(nextPanoLocal);
            this.axis.updateMatrixWorld();

            // move camera on objectCam position
            this.camera.position.copy(this.objectCam.position);
            this.camera.updateMatrixWorld();

            // save axis rotation
            this.axis.rotation.reorder('ZYX');
            this._theta = THREE.Math.radToDeg(this.axis.rotation.x);
            this._phi = THREE.Math.radToDeg(this.axis.rotation.z);
            this.updateAngles();
        }
    }, {
        key: 'update',
        value: function update(dt, updateLoopRestarted) {
            // if we are in a keypressed state, then update position

            // dt will not be relevant when we just started rendering, we consider a 1-frame move in this case
            if (updateLoopRestarted) {
                dt = 16;
            }

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(this.moves), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var move = _step.value;

                    if (move.method === 'translateY') {
                        var normal = this.objectCam.position.clone().normalize();
                        this.camera.position.add(normal.multiplyScalar(move.sign * this.moveSpeed * dt / 1000));
                    } else if (move.method === 'translateX') {
                        // slow camera pan on X
                        this.camera[move.method](move.sign * this.moveSpeed * 0.5 * dt / 1000);
                    } else {
                        // speed camera on tanslate Z
                        this.camera[move.method](move.sign * this.moveSpeed * 2 * dt / 1000);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (this.moves.size || this._isUserInteracting) {
                this.updateAngles();
            }
        }
    }]);
    return ImmersiveControls;
}(THREE.EventDispatcher);

exports.default = ImmersiveControls;