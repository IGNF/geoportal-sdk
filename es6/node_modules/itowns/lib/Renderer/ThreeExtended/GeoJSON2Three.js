'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _Coordinates = require('../../Core/Geographic/Coordinates');

var _Coordinates2 = _interopRequireDefault(_Coordinates);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readCRS(json) {
    if (json.crs) {
        if (json.crs.type.toLowerCase() == 'epsg') {
            return 'EPSG:' + json.crs.properties.code;
        } else if (json.crs.type.toLowerCase() == 'name') {
            var epsgIdx = json.crs.properties.name.toLowerCase().indexOf('epsg:');
            if (epsgIdx >= 0) {
                // authority:version:code => EPSG:[...]:code
                var codeStart = json.crs.properties.name.indexOf(':', epsgIdx + 5);
                if (codeStart > 0) {
                    return 'EPSG:' + json.crs.properties.name.substr(codeStart + 1);
                }
            }
        }
        throw new Error('Unsupported CRS type \'' + json.crs + '\'');
    }
    // assume default crs
    return 'EPSG:4236';
} /**
   * Generated On: 2016-09-28
   * Class: FeatureToolBox
   * Description:
   */

function readCoordinates(crsIn, crsOut, coordinates) {
    // coordinates is a list of pair [[x1, y1], [x2, y2], ..., [xn, yn]]
    var out = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(coordinates), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var pair = _step.value;

            // TODO: 1 is a default z value, makes this configurable
            var coords = new _Coordinates2.default(crsIn, pair[0], pair[1], 1);
            if (crsIn === crsOut) {
                out.push(coords);
            } else {
                out.push(coords.as(crsOut));
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return out;
}

// Helper struct that returns an object { type: "", vertices: [...], indices: [...]}:
// - type is the geom type
// - vertices is an array of THREE.Vector3
// - indices is optional, and are currently only used for polygons
// Multi-* geometry types are merged in one.
var GeometryToVertices = {
    point: function point(crsIn, crsOut, coordinates, filteringExtent) {
        var coords = readCoordinates(crsIn, crsOut, coordinates);
        var vertices = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = (0, _getIterator3.default)(coords), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var c = _step2.value;

                if (filteringExtent && filteringExtent.isPointInside(c)) {
                    vertices.push(c.xyz());
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        return { type: 'point', vertices: vertices };
    },
    polygon: function polygon(crsIn, crsOut, coordinates, filteringExtent) {
        var contour = readCoordinates(crsIn, crsOut, coordinates[0]);

        if (filteringExtent && !filteringExtent.isPointInside(contour[0])) {
            return;
        }
        var vertices2 = [];
        var vertices = new Array(3 * contour.length);
        var offset = 0;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = (0, _getIterator3.default)(contour), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var vertex = _step3.value;

                var v = vertex.xyz();
                v.toArray(vertices, offset);
                vertices2.push(v);
                offset += 3;
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        var triangles = (0, _earcut2.default)(vertices, null, 3);
        // TODO: handle holes

        return { type: 'polygon', vertices: vertices2, indices: triangles };
    },
    lineString: function lineString(crsIn, crsOut, coordinates, filteringExtent) {
        var coords = readCoordinates(crsIn, crsOut, coordinates);
        if (filteringExtent && !filteringExtent.isPointInside(coords[0])) {
            return;
        }

        var vertices = [];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = (0, _getIterator3.default)(coords), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var c = _step4.value;

                vertices.push(c.xyz());
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }

        var indices = [];
        for (var i = 0; i < coords.length - 1; i++) {
            indices.push(i);
            indices.push(i + 1);
        }

        return { type: 'linestring', vertices: vertices, indices: indices };
    },
    merge: function merge() {
        var result = void 0;
        var offset = 0;

        for (var _len = arguments.length, geoms = Array(_len), _key = 0; _key < _len; _key++) {
            geoms[_key] = arguments[_key];
        }

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = (0, _getIterator3.default)(geoms), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var geom = _step5.value;

                if (!geom) {
                    continue;
                }
                if (!result) {
                    result = geom;
                    result.featureVertices = {};
                } else {
                    // merge vertices
                    result.vertices = result.vertices.concat(geom.vertices);
                    if (result.indices) {
                        // merge indices if present
                        for (var i = 0; i < geom.indices.length; i++) {
                            result.indices.push(offset + geom.indices[i]);
                        }
                    }
                }
                result.featureVertices[geom.featureIndex || 0] = { offset: offset, count: geom.vertices.length };
                offset = result.vertices.length;
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        return result;
    },
    multiLineString: function multiLineString(crsIn, crsOut, coordinates, filteringExtent) {
        var result = void 0;
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
            for (var _iterator6 = (0, _getIterator3.default)(coordinates), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var line = _step6.value;

                var l = this.lineString(crsIn, crsOut, line, filteringExtent);
                if (!l) {
                    return;
                }
                // only test the first line
                filteringExtent = undefined;
                result = this.merge(result, l);
            }
        } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                }
            } finally {
                if (_didIteratorError6) {
                    throw _iteratorError6;
                }
            }
        }

        return result;
    },
    multiPolygon: function multiPolygon(crsIn, crsOut, coordinates, filteringExtent) {
        var result = void 0;
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
            for (var _iterator7 = (0, _getIterator3.default)(coordinates), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var polygon = _step7.value;

                var p = this.polygon(crsIn, crsOut, polygon, filteringExtent);
                if (!p) {
                    return;
                }
                // only test the first poly
                filteringExtent = undefined;
                result = this.merge(result, p);
            }
        } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                }
            } finally {
                if (_didIteratorError7) {
                    throw _iteratorError7;
                }
            }
        }

        return result;
    }
};

function readGeometry(crsIn, crsOut, json, filteringExtent) {
    switch (json.type.toLowerCase()) {
        case 'point':
            return GeometryToVertices.point(crsIn, crsOut, [json.coordinates], filteringExtent);
        case 'multipoint':
            return GeometryToVertices.point(crsIn, crsOut, json.coordinates, filteringExtent);
        case 'linestring':
            return GeometryToVertices.lineString(crsIn, crsOut, json.coordinates, filteringExtent);
        case 'multilinestring':
            return GeometryToVertices.multiLineString(crsIn, crsOut, json.coordinates, filteringExtent);
        case 'polygon':
            return GeometryToVertices.polygon(crsIn, crsOut, json.coordinates, filteringExtent);
        case 'multipolygon':
            return GeometryToVertices.multiPolygon(crsIn, crsOut, json.coordinates, filteringExtent);
        case 'geometrycollection':
        default:
            throw new Error('Unhandled geometry type ' + json.type);
    }
}

function readFeature(crsIn, crsOut, json, filteringExtent) {
    var feature = {};
    feature.geometry = readGeometry(crsIn, crsOut, json.geometry, filteringExtent);

    if (!feature.geometry) {
        return;
    }
    feature.properties = {};
    // copy other properties
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
        for (var _iterator8 = (0, _getIterator3.default)((0, _keys2.default)(json)), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var key = _step8.value;

            if (['type', 'geometry'].indexOf(key.toLowerCase()) < 0) {
                feature.properties[key] = json[key];
            }
        }
    } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
                _iterator8.return();
            }
        } finally {
            if (_didIteratorError8) {
                throw _iteratorError8;
            }
        }
    }

    return feature;
}

function verticesToMesh(vertices_and_indices) {
    if (!vertices_and_indices) {
        return;
    }

    // create geometry
    var geometry = new THREE.BufferGeometry();

    var vertices = new Float32Array(3 * vertices_and_indices.vertices.length);
    var offset = 0;
    for (var i = 0; i < vertices_and_indices.vertices.length; i++) {
        vertices_and_indices.vertices[i].toArray(vertices, offset);
        offset += 3;
    }

    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(vertices_and_indices.indices), 1));

    // instanciate mesh
    var result = void 0;
    switch (vertices_and_indices.type) {
        case 'point':
            result = new THREE.Points(geometry);
            break;
        case 'linestring':
            result = new THREE.LineSegments(geometry);
            break;
        case 'polygon':
        default:
            result = new THREE.Mesh(geometry);
            result.material.side = THREE.DoubleSide;
            break;
    }

    result.featureVertices = vertices_and_indices.featureVertices;

    return result;
}

function featureToThree(feature) {
    var mesh = verticesToMesh(feature.geometry);
    mesh.properties = feature.properties;
    return mesh;
}

function readFeatureCollection(crsIn, crsOut, json, filteringExtent) {
    var collec = [];

    var featureIndex = 0;
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
        for (var _iterator9 = (0, _getIterator3.default)(json.features), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var feature = _step9.value;

            var f = readFeature(crsIn, crsOut, feature, filteringExtent);
            if (f) {
                f.geometry.featureIndex = featureIndex;
                collec.push(f);
                featureIndex++;
            }
        }
    } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
                _iterator9.return();
            }
        } finally {
            if (_didIteratorError9) {
                throw _iteratorError9;
            }
        }
    }

    if (collec.length) {
        // sort by types
        var geom = {
            points: collec.filter(function (c) {
                return c.geometry.type === 'point';
            }),
            lines: collec.filter(function (c) {
                return c.geometry.type === 'linestring';
            }),
            polygons: collec.filter(function (c) {
                return c.geometry.type === 'polygon';
            })
        };

        var result = new THREE.Group();
        if (geom.points.length) {
            var idx = result.children.length;
            geom.points.forEach(function (f, index) {
                f.properties._idx = index;f.properties._meshIdx = idx;
            });
            var g = geom.points.map(function (p) {
                return p.geometry;
            });
            var p = GeometryToVertices.merge.apply(GeometryToVertices, (0, _toConsumableArray3.default)(g));
            result.add(verticesToMesh(p));
        }
        if (geom.lines.length) {
            var _idx = result.children.length;
            geom.lines.forEach(function (f, index) {
                f.properties._idx = index;f.properties._meshIdx = _idx;
            });
            var _g = geom.lines.map(function (p) {
                return p.geometry;
            });
            var _p = GeometryToVertices.merge.apply(GeometryToVertices, (0, _toConsumableArray3.default)(_g));
            result.add(verticesToMesh(_p));
        }
        if (geom.polygons.length) {
            var _idx2 = result.children.length;
            geom.polygons.forEach(function (f, index) {
                f.properties._idx = index;f.properties._meshIdx = _idx2;
            });
            var _g2 = geom.polygons.map(function (p) {
                return p.geometry;
            });
            var _p2 = GeometryToVertices.merge.apply(GeometryToVertices, (0, _toConsumableArray3.default)(_g2));
            result.add(verticesToMesh(_p2));
        }
        // remember individual features properties
        // eslint-disable-next-line arrow-body-style
        result.features = collec.map(function (c) {
            return { properties: c.properties };
        });
        if (result.children.length) {
            return result;
        }
    }
}

exports.default = {
    parse: function parse(crsOut, json, filteringExtent) {
        var crsIn = readCRS(json);
        switch (json.type.toLowerCase()) {
            case 'featurecollection':
                return readFeatureCollection(crsIn, crsOut, json, filteringExtent);
            case 'feature':
                return featureToThree(readFeature(crsIn, crsOut, json, filteringExtent));
            default:
                throw new Error('Unsupported GeoJSON type: \'' + json.type);
        }
    }
};