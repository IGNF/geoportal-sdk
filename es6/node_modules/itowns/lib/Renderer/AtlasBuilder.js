'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = pack;

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _Capabilities = require('../Core/System/Capabilities');

var _Capabilities2 = _interopRequireDefault(_Capabilities);

var _Packer = require('./Packer');

var _Packer2 = _interopRequireDefault(_Packer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pack(images, uvs) {
    var atlasCanvas = document.createElement('canvas');
    var colorBleedHalfOffset = images.length == 1 ? 0 : 2;
    var maxSize = _Capabilities2.default.getMaxTextureSize();
    var blocks = [];
    for (var i = 0; i < images.length; i++) {
        var img = images[i];
        var replaceWithEmpty = !img;
        var sWidth = replaceWithEmpty ? 1 : img.width;
        var sHeight = replaceWithEmpty ? 1 : img.height;

        blocks.push({
            index: i,
            w: sWidth + 2 * colorBleedHalfOffset,
            h: sHeight,
            empty: replaceWithEmpty
        });
    }

    blocks.sort(function (a, b) {
        return Math.max(a.w, a.h) < Math.max(b.w, b.h);
    });
    // TODO: if all images don't fit on 1 row, add vertical spacing

    var _fit = (0, _Packer2.default)(blocks, maxSize, maxSize),
        maxX = _fit.maxX,
        maxY = _fit.maxY;

    atlasCanvas.width = maxX;
    atlasCanvas.height = maxY;

    var uv = [];
    var ctx = atlasCanvas.getContext('2d');

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(blocks), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var block = _step.value;

            var _i = block.index;
            var _img = images[_i];

            var uvSource = {
                x: uvs[_i].x * uvs[_i].z,
                y: uvs[_i].y * uvs[_i].z,
                z: uvs[_i].z
            };

            var _sWidth = block.empty ? 1 : _img.width;
            var _sHeight = block.empty ? 1 : _img.height;

            var xOffset = block.fit.x + colorBleedHalfOffset;
            var yOffset = block.fit.y; // + colorBleedHalfOffset;

            var uvScaleDest = new THREE.Vector4(xOffset / atlasCanvas.width, yOffset / atlasCanvas.height, uvSource.z * _sWidth / atlasCanvas.width, uvSource.z * _sHeight / atlasCanvas.height);

            if (!block.empty) {
                ctx.drawImage(_img, _img.width * uvSource.x, // sx
                _img.height * uvSource.y, // sy
                uvSource.z * _sWidth, // sWidth
                uvSource.z * _sHeight, // sHeight
                xOffset, // dx
                yOffset, // dy
                uvSource.z * _sWidth, // dWidth
                uvSource.z * _sHeight); // dHeight

                ctx.globalCompositeOperation = 'destination-over';

                ctx.drawImage(_img, _img.width * uvSource.x, // sx
                _img.height * uvSource.y, // sy
                uvSource.z * _sWidth, // sWidth
                uvSource.z * _sHeight, // sHeight
                xOffset - colorBleedHalfOffset, // dx
                yOffset, // dy
                uvSource.z * _sWidth + 2 * colorBleedHalfOffset, // dWidth
                uvSource.z * _sHeight);

                ctx.globalCompositeOperation = 'source-over';
            }

            uv.push(uvScaleDest);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var atlas = new THREE.CanvasTexture(atlasCanvas);

    atlas.generateMipmaps = false;
    atlas.magFilter = THREE.LinearFilter;
    atlas.minFilter = THREE.LinearFilter;
    atlas.anisotropy = 1;

    return { atlas: atlas, uv: uv };
}