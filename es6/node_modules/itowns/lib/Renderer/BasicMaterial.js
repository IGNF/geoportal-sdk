'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _SimpleVS = "#version 100\n\nprecision highp float;\nprecision highp int;\n\n#define SHADER_NAME SimpleMaterial\n#define VERTEX_TEXTURES\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n\n//attribute vec2      uv;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform mat4        projectionMatrix;\nuniform mat4        modelViewMatrix;\n\nuniform mat4       mVPMatRTC;\nuniform bool       useRTC;\nvarying float      light;\n\n// IE error : Initializer for const variable must initialize to a constant value\n//const vec3 dir =  normalize(vec3(1.0,1.0,0.5));\n\nvoid main()\n{\n  vec3 dir =  normalize(vec3(1.0,1.0,0.5));\n\n  if(useRTC)\n        gl_Position = mVPMatRTC * vec4( position ,1.0 );\n  else\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n    float h  = max(0.05,(1.0 - min(position.y / 50.0,1.0)));\n\n    light    =   h / max(0.25,dot(dir,normal));\n\n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n\n}";

var _SimpleVS2 = _interopRequireDefault(_SimpleVS);

var _SimpleFS = "#version 100\n\n#extension GL_EXT_frag_depth : enable\n\n#define SHADER_NAME simpleMaterial\n#define VERTEX_TEXTURES\n\nprecision highp float;\nprecision highp int;\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif\n\nuniform vec3 diffuseColor;\nuniform bool lightingEnabled;\nvarying float light;\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    vec4 color = lightingEnabled ? vec4( diffuseColor / light,1.0) : vec4( diffuseColor, 1.0);\n\n    gl_FragColor = color;\n}";

var _SimpleFS2 = _interopRequireDefault(_SimpleFS);

var _LogDepthBuffer = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n    #define EPSILON 1e-6\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n";

var _LogDepthBuffer2 = _interopRequireDefault(_LogDepthBuffer);

var _Capabilities = require('../Core/System/Capabilities');

var _Capabilities2 = _interopRequireDefault(_Capabilities);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BasicMaterial(color) {
    // Constructor

    THREE.RawShaderMaterial.call(this);

    this.vertexShaderHeader = '';
    this.fragmentShaderHeader = '';

    var logarithmicDepthBuffer = _Capabilities2.default.isLogDepthBufferSupported();

    if (logarithmicDepthBuffer) {
        this.fragmentShaderHeader += '#extension GL_EXT_frag_depth : enable\n';
    }

    this.fragmentShaderHeader += 'precision highp float;\n';
    this.fragmentShaderHeader += 'precision highp int;\n';

    if (logarithmicDepthBuffer) {
        this.fragmentShaderHeader += '#define USE_LOGDEPTHBUF\n';
        this.fragmentShaderHeader += '#define USE_LOGDEPTHBUF_EXT\n';
        this.fragmentShaderHeader += _LogDepthBuffer2.default;
    }

    this.fragmentShaderHeader += '#define VERTEX_TEXTURES\n';
    this.vertexShaderHeader = this.fragmentShaderHeader;

    this.vertexShader = this.vertexShaderHeader + _SimpleVS2.default;
    this.fragmentShader = this.fragmentShaderHeader + _SimpleFS2.default;

    this.uniforms = {
        diffuseColor: { value: color || new THREE.Color() },
        useRTC: { value: true },
        mVPMatRTC: { value: new THREE.Matrix4() },
        distanceFog: { value: 1000000000.0 },
        uuid: { value: 0 },
        debug: { value: false },
        selected: { value: false },
        lightingEnabled: { value: false }
    };
} /*
   * To change this license header, choose License Headers in Project Properties.
   * To change this template file, choose Tools | Templates
   * and open the template in the editor.
   */

BasicMaterial.prototype = (0, _create2.default)(THREE.RawShaderMaterial.prototype);
BasicMaterial.prototype.constructor = BasicMaterial;

BasicMaterial.prototype.enableRTC = function enableRTC(enable) {
    this.uniforms.useRTC.value = enable;
};

BasicMaterial.prototype.setDebug = function setDebug(v) {
    this.uniforms.debug.value = v;
};

BasicMaterial.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
    this.uniforms.mVPMatRTC.value = rtc;
};

BasicMaterial.prototype.getMatrixRTC = function getMatrixRTC() {
    return this.uniforms.mVPMatRTC.value;
};

BasicMaterial.prototype.setUuid = function setUuid(uuid) {
    this.uniforms.uuid.value = uuid;
};

BasicMaterial.prototype.getUuid = function getUuid() {
    return this.uniforms.uuid.value;
};

BasicMaterial.prototype.setFogDistance = function setFogDistance(df) {
    this.uniforms.distanceFog.value = df;
};

BasicMaterial.prototype.setSelected = function setSelected(selected) {
    this.uniforms.selected.value = selected;
};

exports.default = BasicMaterial;