'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _BasicMaterial = require('./BasicMaterial');

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _TileDepthFS = "const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\nvec4 pack1K ( float depth ) {\n    depth /= 100000000.0;\n    vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n    res -= res.xxyz * bitMsk;\n    return res;\n}\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\t   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n        float z = 1.0/ gl_FragCoord.w ;\n        gl_FragColor = pack1K(z);\n    #else\n        float z = gl_FragCoord.z / gl_FragCoord.w;\n        gl_FragColor = pack1K(z);\n    #endif\n\n}\n";

var _TileDepthFS2 = _interopRequireDefault(_TileDepthFS);

var _TileDepthVS = "attribute vec2      uv_wgs84;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform sampler2D   dTextures_00[1];\nuniform vec3        offsetScale_L00[1];\nuniform int         texturesCount;\nuniform mat4        mVPMatRTC;\n\nvoid main() {\n\n        vec4 vPosition;\n\n        if(texturesCount > 0) {\n            vec2    vVv = vec2(uv_wgs84.x * offsetScale_L00[0].z + offsetScale_L00[0].x,(1.0 - uv_wgs84.y) * offsetScale_L00[0].z + offsetScale_L00[0].y);\n\n            float   dv  = max(texture2D( dTextures_00[0], vVv ).w, 0.);\n\n            vPosition   = vec4(position + normal * dv, 1.0 );\n        }\n        else {\n            vPosition = vec4(position, 1.0);\n        }\n\n        gl_Position = mVPMatRTC * vPosition;\n\n        #ifdef USE_LOGDEPTHBUF\n\n            gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n            #ifdef USE_LOGDEPTHBUF_EXT\n\n                vFragDepth = 1.0 + gl_Position.w;\n\n            #else\n\n                gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n            #endif\n\n        #endif\n\n}\n";

var _TileDepthVS2 = _interopRequireDefault(_TileDepthVS);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TileDepthMaterial = function TileDepthMaterial(otherMaterial) {
    _BasicMaterial2.default.call(this);

    this.vertexShader = this.vertexShaderHeader + _TileDepthVS2.default;
    this.fragmentShader = this.fragmentShaderHeader + _TileDepthFS2.default;

    // Why connect directily uniform doesn't work?
    // Verify attributes's shaders

    this.uniforms.dTextures_00 = new THREE.Uniform(otherMaterial.textures[0]);
    this.uniforms.texturesCount = new THREE.Uniform(otherMaterial.loadedTexturesCount[0]);
    this.uniforms.offsetScale_L00 = new THREE.Uniform(otherMaterial.offsetScale[0]);
};

TileDepthMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
TileDepthMaterial.prototype.constructor = TileDepthMaterial;

exports.default = TileDepthMaterial;