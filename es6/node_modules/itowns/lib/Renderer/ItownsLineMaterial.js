'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _BasicMaterial = require('./BasicMaterial');

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _LineVS = "#version 100\n\nprecision highp float;\nprecision highp int;\n\n//#define SHADER_NAME LineShaderMaterial\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\nattribute vec3  position;\nattribute vec3  previous;\nattribute vec3  next;\n\nattribute float side;\nattribute float width;\nattribute vec2 uv;\n\n\nuniform mat4   projectionMatrix;\nuniform mat4   modelViewMatrix;\n\nuniform float\tTHICKNESS;\t// the thickness of the line in pixels\nuniform float\tMITER_LIMIT;\t// 1.0: always miter, -1.0: never miter, 0.75: default\nuniform vec2\tWIN_SCALE;\t// the size of the viewport in pixels\n\nuniform float opacity;\nuniform float sizeAttenuation;\nuniform vec3 color;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPosition;\n\n\nvec2 screen_space(vec4 vertex)\n{\n\treturn vec2( vertex.xy / vertex.w ) * WIN_SCALE;\n}\n\nvec2 fix( vec4 i, float aspect ) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n\nvoid main() {\n\n                float aspect = WIN_SCALE.x / WIN_SCALE.y;\n        \tfloat pixelWidthRatio = 1. / (WIN_SCALE.x * projectionMatrix[0][0]);\n                vColor = vec4( color, opacity );\n                vUV = uv;\n\n\t\tvec4 projectedPrePoint = projectionMatrix * modelViewMatrix * vec4(previous,1.0);\n\t\tvec4 projectedCurPoint = projectionMatrix * modelViewMatrix *vec4(position,1.0);\n\t\tvec4 projectedNextPoint = projectionMatrix * modelViewMatrix *vec4(next,1.0);\n\n                #ifdef USE_LOGDEPTHBUF\n\n                    projectedPrePoint.z = log2(max( EPSILON, projectedPrePoint.w + 1.0 )) * logDepthBufFC;\n                    projectedCurPoint.z = log2(max( EPSILON, projectedCurPoint.w + 1.0 )) * logDepthBufFC;\n                    projectedNextPoint.z = log2(max( EPSILON, projectedNextPoint.w + 1.0 )) * logDepthBufFC;\n\n                    #ifdef USE_LOGDEPTHBUF_EXT\n\n                        vFragDepth = 1.0 + gl_Position.w;\n\n                    #else\n\n                        projectedPrePoint.z = (projectedPrePoint.z - 1.0) * projectedPrePoint.w;\n                        projectedCurPoint.z = (projectedCurPoint.z - 1.0) * projectedCurPoint.w;\n                        projectedNextPoint.z = (projectedNextPoint.z - 1.0) * projectedNextPoint.w;\n\n                    #endif\n\n                #endif\n\n                \n                vec2 previousScreen = fix( projectedPrePoint,aspect );\t// start of previous segment\n                vec2 currentScreen = fix( projectedCurPoint ,aspect);\t// end of previous segment, start of current segment\n                vec2 nextScreen = fix( projectedNextPoint ,aspect);\t// end of current segment, start of next segment\n\n\n                float pixelWidth = projectedCurPoint.w * pixelWidthRatio;\n                float w = 1.8*pixelWidth * THICKNESS * width;\n\n                if(sizeAttenuation == 1.0) {\n                        w = 1.8 * THICKNESS * width;\n                }\n\n                //starting point uses (next - current)\n                vec2 dir = vec2(0.0);\n                //float len = THICKNESS;\n\n                if (currentScreen == previousScreen) {\n                        dir = normalize(nextScreen - currentScreen);\n                } \n                //ending point uses (current - previous)\n                else if (currentScreen == nextScreen) {\n                       dir = normalize(currentScreen - previousScreen);\n                }\n                //somewhere in middle, needs a join\n                else {\n                         //get directions from (C - B) and (B - A)\n                         vec2 dirA = normalize((currentScreen - previousScreen));\n                         if (MITER_LIMIT == 1.0) {\n                                vec2 dirB = normalize(nextScreen - currentScreen);\n                                //now compute the miter join normal and length\n                                vec2 tangent = normalize(dirA + dirB);\n                                vec2 perp = vec2(-dirA.y, dirA.x);\n                                vec2 miter = vec2(-tangent.y, tangent.x);\n                                dir = tangent;\n                                //len = THICKNESS / dot(miter, perp);\n                                //w = clamp( w / dot( miter, perp ), 0., 4. * THICKNESS * width );\n                        } else {\n                             dir = dirA;\n                        }\n                }\n\n                vec2 normal = vec2(-dir.y, dir.x);\n                normal.x /= aspect;\n                normal *= 0.5 * w;\n                //normal *= len/2.0;\n\n                vec4 offset = vec4(normal*side, 0.0, 1.0);\n                projectedCurPoint.xy += offset.xy;\n               \n                vPosition    = ( modelViewMatrix * vec4( position, 1. ) ).xyz;\n                gl_Position  = projectedCurPoint;\n                gl_PointSize = 10.0;\n}";

var _LineVS2 = _interopRequireDefault(_LineVS);

var _LineFS = "#extension GL_OES_standard_derivatives : enable\n//#define SHADER_NAME LineShaderMaterial\n\nprecision highp float;\nprecision highp int;\n\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\nuniform sampler2D texture;\nuniform float useTexture;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPosition;\n\nvoid main() {\n\tvec4 c = vColor;\n        if( useTexture == 1. ) c = texture2D( texture, vUV );\n        gl_FragColor = c;\n}";

var _LineFS2 = _interopRequireDefault(_LineFS);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

var ItownsLineMaterial = function ItownsLineMaterial(options) {
  _BasicMaterial2.default.call(this);

  if (options === undefined) {
    throw new Error('options is required');
  }

  this.vertexShader = _LineVS2.default;
  this.fragmentShader = _LineFS2.default;

  this.wireframe = false;

  var texture = new THREE.TextureLoader().load(options.texture);

  this.uniforms.time = { value: options.time };
  this.uniforms.THICKNESS = { value: options.linewidth };
  this.uniforms.MITER_LIMIT = { value: 1.0 };
  this.uniforms.WIN_SCALE = { value: new THREE.Vector2(window.innerWidth, window.innerHeight) };
  this.uniforms.texture = { type: 't', value: texture };
  this.uniforms.useTexture = { value: options.useTexture };
  this.uniforms.opacity = { type: 'f', value: options.opacity };
  this.uniforms.sizeAttenuation = { type: 'f', value: options.sizeAttenuation };
  this.uniforms.color = { type: 'v3', value: options.color };

  this.transparent = true;
};

ItownsLineMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
ItownsLineMaterial.prototype.constructor = ItownsLineMaterial;

exports.default = ItownsLineMaterial;