'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _Sensor = require('./Sensor');

var _Sensor2 = _interopRequireDefault(_Sensor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 *
 * @author AD IGN
 * Class where we get the Extrinseque and Intrinseque parameters of the system. Camera (laser soon).
 * Next we will dynamically load configuration from server in case of changes
 * @Depends Sensor.js
 */

var Ori = {

    initiated: false,
    options: null,
    sensors: [],

    init: function init(options) {
        var _this = this;

        var baseUrl = options.cam; // PanoramicProvider.getMetaDataSensorURL();

        return fetch(baseUrl).then(function (response) {
            if (response.status < 200 || response.status >= 300) {
                throw new Error('Error loading ' + baseUrl + ': status ' + response.status);
            }
            return response.json();
        }).then(function (data) {
            _this.handleDBData(data);
            return _this.initiated;
        });
    },
    handleDBData: function handleDBData(data) {
        for (var i = 0; i < data.length; ++i) // For all DB sensor info we create sensor object
        {
            this.sensors.push(new _Sensor2.default(data[i]));
        }
        this.initiated = true;
        // console.log('Orientation module is loaded');
    },


    // Global orientation matrix of the vehicule
    // Warning: heading pitch roll not all in right side in itowns ref
    // Pitch and Roll are in opposite
    computeMatOriFromHeadingPitchRoll: function computeMatOriFromHeadingPitchRoll(heading, pitch, roll) {
        heading = (180 - parseFloat(heading)) / 180 * Math.PI; // parseFloat(heading) / 180 * Math.PI;  // Deg to Rad // Axe Y
        pitch = parseFloat(pitch) / 180 * Math.PI; // Deg to Rad // axe X
        roll = parseFloat(roll) / 180 * Math.PI; // Deg to Rad   // axe Z
        // With quaternion  //set rotation.order to "YXZ", which is equivalent to "heading, pitch, and roll"
        var q = new THREE.Quaternion().setFromEuler(new THREE.Euler(-pitch, heading, -roll, 'YXZ'), true);
        return new THREE.Matrix3().makeRotationFromQuaternion(q);
    },
    getPosition: function getPosition() {
        var sum = new THREE.Vector3(0, 0, 0);
        for (var i = 0; i < this.sensors.length; ++i) {
            sum = sum.add(this.sensors[i].position);
        }
        return sum.divideScalar(this.sensors.length);
    },


    // deprecated methods
    getDistortion: function getDistortion(i) {
        return this.sensors[i].distortion;
    },
    getSommet: function getSommet(i) {
        return this.sensors[i].position;
    },
    getProjection: function getProjection(i) {
        return this.sensors[i].projection;
    },
    getRotation: function getRotation(i) {
        return this.sensors[i].rotation;
    },
    getMask: function getMask(i) {
        return this.sensors[i].mask;
    },
    getSize: function getSize(i) {
        return this.sensors[i].size;
    },
    getPPS: function getPPS(i) {
        return this.sensors[i].pps;
    },
    getMatrix: function getMatrix(i) {
        return new THREE.Matrix3().multiplyMatrices(this.getRotation(i), this.getProjection(i));
    }
};

exports.default = Ori;