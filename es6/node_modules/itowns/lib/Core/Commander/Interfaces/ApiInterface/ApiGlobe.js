'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.INITIALIZED_EVENT = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _customEvent = require('custom-event');

var _customEvent2 = _interopRequireDefault(_customEvent);

var _Scene = require('../../../../Scene/Scene');

var _Scene2 = _interopRequireDefault(_Scene);

var _Globe = require('../../../../Globe/Globe');

var _Globe2 = _interopRequireDefault(_Globe);

var _WMTS_Provider = require('../../Providers/WMTS_Provider');

var _WMTS_Provider2 = _interopRequireDefault(_WMTS_Provider);

var _WMS_Provider = require('../../Providers/WMS_Provider');

var _WMS_Provider2 = _interopRequireDefault(_WMS_Provider);

var _TileProvider = require('../../Providers/TileProvider');

var _TileProvider2 = _interopRequireDefault(_TileProvider);

var _KML_Provider = require('../../Providers/KML_Provider');

var _KML_Provider2 = _interopRequireDefault(_KML_Provider);

var _WFS_Provider = require('../../Providers/WFS_Provider');

var _WFS_Provider2 = _interopRequireDefault(_WFS_Provider);

var _GpxUtils = require('../../Providers/GpxUtils');

var _GpxUtils2 = _interopRequireDefault(_GpxUtils);

var _Coordinates = require('../../../Geographic/Coordinates');

var _Fetcher = require('../../Providers/Fetcher');

var _Fetcher2 = _interopRequireDefault(_Fetcher);

var _LayerUpdateStrategy = require('../../../../Scene/LayerUpdateStrategy');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Generated On: 2015-10-5
 * Class: ApiGlobe
 * Description: Classe façade pour attaquer les fonctionnalités du code.
 */

var sceneIsLoaded = false;
var INITIALIZED_EVENT = exports.INITIALIZED_EVENT = 'initialized';

var eventRange = new _customEvent2.default('rangeChanged');
var eventOrientation = new _customEvent2.default('orientationchanged');
var eventPan = new _customEvent2.default('panchanged');
var eventLayerAdded = new _customEvent2.default('layeradded');
var eventLayerRemoved = new _customEvent2.default('layerremoved');
var eventLayerChanged = new _customEvent2.default('layerchanged');
var eventLayerChangedVisible = new _customEvent2.default('layerchanged:visible');
var eventLayerChangedOpacity = new _customEvent2.default('layerchanged:opacity');
var eventLayerChangedIndex = new _customEvent2.default('layerchanged:index');

var enableAnimation = false;

var defer = function defer() {
    var deferedPromise = {};
    deferedPromise.promise = new _promise2.default(function (resolve, reject) {
        deferedPromise.resolve = resolve;
        deferedPromise.reject = reject;
    });
    return deferedPromise;
};

function ApiGlobe() {
    // Constructor
    this.scene = null;
    this.commandsTree = null;
    this.viewerDiv = null;
    this.callback = null;
}

ApiGlobe.prototype.constructor = ApiGlobe;

/**
 * This function gives a chance to the matching provider to pre-process some
 * values for a layer.
 */
function preprocessLayer(layer, provider) {
    if (!layer.updateStrategy) {
        layer.updateStrategy = {
            type: _LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC
        };
    }

    if (provider.tileInsideLimit) {
        layer.tileInsideLimit = provider.tileInsideLimit.bind(provider);
    }

    if (provider.tileTextureCount) {
        layer.tileTextureCount = provider.tileTextureCount.bind(provider);
    }

    if (provider.preprocessDataLayer) {
        provider.preprocessDataLayer(layer);
    }
}

/**
 * Init the geometry layer of the Scene.
 */
ApiGlobe.prototype.init = function init() {
    var map = this.scene.getMap();
    map.tiles.init(map.layersConfiguration.getGeometryLayers()[0], map.layersConfiguration.lightingLayers[0]);
};

/**
 * Add the geometry layer to the scene.
 */
ApiGlobe.prototype.addGeometryLayer = function addGeometryLayer(layer) {
    preprocessLayer(layer, this.scene.scheduler.getProtocolProvider(layer.protocol));
    var map = this.scene.getMap();
    if (this.getLayerById(layer.id)) {
        // eslint-disable-next-line no-console
        console.error('Error : id "' + layer.id + '" already exist, WARNING your layer isn\'t added');
    } else {
        map.layersConfiguration.addGeometryLayer(layer);
        this.viewerDiv.dispatchEvent(eventLayerAdded);
    }
};

/**
 * The intellectual property rights
 * @typedef {Object} Attribution
 * @property {string} name
 * @property {string} url
 */

/**
 * Options to wms protocol
 * @typedef {Object} OptionsWms
 * @property {Attribution} attribution The intellectual property rights for the layer
 * @property {string} name
 * @property {string} mimetype
 */

/**
 * Options to wtms protocol
 * @typedef {Object} OptionsWmts
 * @property {Attribution} attribution The intellectual property rights for the layer
 * @property {string} name
 * @property {string} mimetype
 * @property {string} tileMatrixSet
 * @property {Array.<Object>} tileMatrixSetLimits The limits for the tile matrix set
 * @property {number} tileMatrixSetLimits.minTileRow Minimum row for tiles at the level
 * @property {number} tileMatrixSetLimits.maxTileRow Maximum row for tiles at the level
 * @property {number} tileMatrixSetLimits.minTileCol Minimum col for tiles at the level
 * @property {number} tileMatrixSetLimits.maxTileCol Maximum col for tiles at the level
 * @property {Object} [zoom]
 * @property {Object} [zoom.min] layer's zoom minimum
 * @property {Object} [zoom.max] layer's zoom maximum
 */

/**
 * Layer
 * @typedef {Object} Layer
 * @property {string} id Unique layer's id
 * @property {string} layer.protocol wmts and wms (wmtsc for custom deprecated)
 * @property {string} layer.url Base URL of the repository or of the file(s) to load
 * @property {Object} layer.updateStrategy strategy to load imagery files
 * @property {OptionsWmts|OptionsWms} layer.options WMTS or WMS options
 */

/**
 * This function adds an imagery layer to the scene. The layer id must be unique.
 * The protocol rules wich parameters are then needed for the function.
 * @constructor
 * @param {Layer} Layer
 */

ApiGlobe.prototype.addImageryLayer = function addImageryLayer(layer) {
    var _this = this;

    preprocessLayer(layer, this.scene.scheduler.getProtocolProvider(layer.protocol));
    if (this.getLayerById(layer.id)) {
        // eslint-disable-next-line no-console
        console.error('Error : id "' + layer.id + '" already exist, WARNING your layer isn\'t added');
    } else {
        this.scene.getMap().layersConfiguration.addColorLayer(layer);
        this.scene.notifyChange(1, true);
        this.setSceneLoaded().then(function () {
            _this.viewerDiv.dispatchEvent(eventLayerAdded);
        });
    }
};

/**
 * This function adds an feature layer to the scene. The layer id must be unique.
 * Add a feature Layer to the scene graph. Handle vector data such as GPX, KML, GeoJSON,...
 * Needs to be rewrited to have a singleton kml provider for n feature layers
 * @constructor
 * @param {Layer} layer.
 */
ApiGlobe.prototype.addFeatureLayer = function addFeatureLayer(layer) {
    var _this2 = this;

    var provider = this.scene.scheduler.getProtocolProvider(layer.protocol);
    preprocessLayer(layer, provider);
    var map = this.scene.getMap();
    map.layersConfiguration.addGeometryLayer(layer);
    map.add(layer.root.parent);
    this.scene.gfxEngine.add3DScene(layer.root);

    if (layer.local && layer.protocol === 'kml') {
        provider.parseKML(layer.url).then(function (obj) {
            var state = _this2.scene.getMap().layersConfiguration.layersState[layer.id];
            state.polygons = obj.objLinesPolyToRaster.polygons;
            layer.root.add(obj.geoFeat);
        });
    }
};

ApiGlobe.prototype.pickFeatureLayer = function pickFeatureLayer(layerId, geoCoord) {
    var polygons = this.scene.getMap().layersConfiguration.layersState[layerId].polygons;
    if (polygons) {
        var tools = this.scene.scheduler.getProtocolProvider('wfs').featureToolBox;
        var attributes = tools.showFeatureAttributesAtPos(geoCoord, polygons);
        if (attributes) {
            return attributes;
        }
    }
};

/**
 * This function adds an imagery layer to the scene using a JSON file. The layer id must be unique. The protocol rules wich parameters are then needed for the function.
 * @constructor
 * @param {Layer} layer.
 * @return     {layer}  The Layer.
 */

ApiGlobe.prototype.addImageryLayerFromJSON = function addImageryLayerFromJSON(url) {
    var _this3 = this;

    return _Fetcher2.default.json(url).then(function (result) {
        _this3.addImageryLayer(result);
    });
};

/**
 * This function adds an imagery layer to the scene using an array of JSON files. The layer id must be unique. The protocol rules wich parameters are then needed for the function.
 * @constructor
 * @param {Layers} array - An array of JSON files.
 * @return     {layer}  The Layers.
 */

ApiGlobe.prototype.addImageryLayersFromJSONArray = function addImageryLayersFromJSONArray(urls) {
    var _this4 = this;

    var proms = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(urls), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var url = _step.value;

            proms.push(_Fetcher2.default.json(url).then(this.addImageryLayer.bind(this)));
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return _promise2.default.all(proms).then(function () {
        return _this4.scene.getMap().layersConfiguration.getColorLayers();
    });
};

ApiGlobe.prototype.addFeatureLayerFromJSON = function addFeatureLayerFromJSON(url) {
    var _this5 = this;

    return _Fetcher2.default.json(url).then(function (result) {
        _this5.addFeatureLayer(result);
    });
};

ApiGlobe.prototype.addFeatureLayersFromJSONArray = function addFeatureLayersFromJSONArray(urls) {
    var _this6 = this;

    var proms = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = (0, _getIterator3.default)(urls), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var url = _step2.value;

            proms.push(_Fetcher2.default.json(url));
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return _promise2.default.all(proms).then(function (layers) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = (0, _getIterator3.default)(layers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var layer = _step3.value;

                _this6.addFeatureLayer(layer);
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        return _this6.scene.getMap().layersConfiguration.getGeometryLayers();
    });
};

ApiGlobe.prototype.addFeatureFromJSON = function addFeatureFromJSON(url, options) {
    var _this7 = this;

    return _Fetcher2.default.json(url).then(function (result) {
        (0, _assign2.default)(result, options);
        _this7.addFeature(result);
    });
};

ApiGlobe.prototype.addFeaturesFromJSONArray = function addFeaturesFromJSONArray(urls) {
    var _this8 = this;

    var proms = [];
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = (0, _getIterator3.default)(urls), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var url = _step4.value;

            proms.push(_Fetcher2.default.json(url));
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    return _promise2.default.all(proms).then(function (features) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = (0, _getIterator3.default)(features), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var feature = _step5.value;

                _this8.addFeature(feature);
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }
    });
};

ApiGlobe.prototype.moveLayerUp = function moveLayerUp(layerId) {
    this.scene.getMap().layersConfiguration.moveLayerUp(layerId);
    this.scene.getMap().updateLayersOrdering();
    this.scene.renderScene3D();
};

ApiGlobe.prototype.moveLayerDown = function moveLayerDown(layerId) {
    this.scene.getMap().layersConfiguration.moveLayerDown(layerId);
    this.scene.getMap().updateLayersOrdering();
    this.scene.renderScene3D();
};

/**
 * Moves a specific layer to a specific index in the layer list. This function has no effect if the layer is moved to its current index.
 * @constructor
 * @param      {string}  layerId   The layer's idendifiant
 * @param      {number}  newIndex   The new index
 */
ApiGlobe.prototype.moveLayerToIndex = function moveLayerToIndex(layerId, newIndex) {
    this.scene.getMap().layersConfiguration.moveLayerToIndex(layerId, newIndex);
    this.scene.getMap().updateLayersOrdering();
    this.scene.renderScene3D();
    eventLayerChangedIndex.layerIndex = newIndex;
    eventLayerChangedIndex.layerId = layerId;
    this.viewerDiv.dispatchEvent(eventLayerChangedIndex);
};

/**
 * Removes a specific imagery layer from the current layer list. This removes layers inserted with addLayer().
 * @constructor
 * @param      {string}   id      The identifier
 * @return     {boolean}  { description_of_the_return_value }
 */
ApiGlobe.prototype.removeImageryLayer = function removeImageryLayer(id) {
    if (this.scene.getMap().layersConfiguration.removeColorLayer(id)) {
        this.scene.getMap().removeColorLayer(id);
        this.scene.renderScene3D();
        eventLayerRemoved.layer = id;
        this.viewerDiv.dispatchEvent(eventLayerRemoved);
        return true;
    }

    return false;
};

/**
 * Add an elevation layer to the map. Elevations layers are used to build the terrain.
 * Only one elevation layer is used, so if multiple layers cover the same area, the one
 * with best resolution is used (or the first one is resolution are identical).
 * The layer id must be unique amongst all layers already inserted.
 * The protocol rules which parameters are then needed for the function.
 * @constructor
 * @param {Layer} layer
 */

ApiGlobe.prototype.addElevationLayer = function addElevationLayer(layer) {
    var _this9 = this;

    if (layer.protocol === 'wmts' && layer.options.tileMatrixSet !== 'WGS84G') {
        throw new Error('Only WGS84G tileMatrixSet is currently supported for WMTS elevation layers');
    }

    preprocessLayer(layer, this.scene.scheduler.getProtocolProvider(layer.protocol));
    if (this.getLayerById(layer.id)) {
        // eslint-disable-next-line no-console
        console.error('Error : id "' + layer.id + '" already exist, WARNING your layer isn\'t added');
    } else {
        this.scene.getMap().layersConfiguration.addElevationLayer(layer);
        this.scene.notifyChange(1, true);
        this.setSceneLoaded().then(function () {
            _this9.viewerDiv.dispatchEvent(eventLayerAdded);
        });
    }
};

/**
 * Add an elevation layer to the map using a JSON file.
 * Elevations layers are used to build the terrain.
 * Only one elevation layer is used, so if multiple layers cover the same area, the one
 * with best resolution is used (or the first one is resolution are identical).
 * The layer id must be unique amongst all layers already inserted.
 * The protocol rules which parameters are then needed for the function.
 * @constructor
 * @param {Layers} array - An array of JSON files.
* @return     {layer}  The Layers.
 */

ApiGlobe.prototype.addElevationLayersFromJSON = function addElevationLayersFromJSON(url) {
    var _this10 = this;

    return _Fetcher2.default.json(url).then(function (result) {
        _this10.addElevationLayer(result);
    });
};

/**
 * Add an elevation layer to the map using an array of JSON files.
 * Elevations layers are used to build the terrain.
 * Only one elevation layer is used, so if multiple layers cover the same area, the one
 * with best resolution is used (or the first one is resolution are identical).
 * The layer id must be unique amongst all layers already inserted.
 * The protocol rules which parameters are then needed for the function.
 * @constructor
 * @param {Layer} layer.
 * @return     {layer}  The Layers.
 */

ApiGlobe.prototype.addElevationLayersFromJSONArray = function addElevationLayersFromJSONArray(urls) {
    var _this11 = this;

    var proms = [];

    for (var i = 0; i < urls.length; i++) {
        proms.push(_Fetcher2.default.json(urls[i]).then(this.addElevationLayer.bind(this)));
    }

    return _promise2.default.all(proms).then(function () {
        return _this11.scene.getMap().layersConfiguration.getElevationLayers();
    });
};

/**
 * Gets the minimum zoom level of the chosen layer.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/66r8ugq0/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @param {index} index - The index of the layer.
 * @return     {number}  The min of the level.
 */
ApiGlobe.prototype.getMinZoomLevel = function getMinZoomLevel(index) {
    var layer = this.getImageryLayers()[index];
    if (layer && layer.options.zoom) {
        return layer.options.zoom.min;
    } else {
        var layers = this.getImageryLayers();
        var min = Infinity;
        for (var i = layers.length - 1; i >= 0; i--) {
            if (layers[i].options.zoom) {
                min = Math.min(min, layers[i].options.zoom.min);
            }
        }
        return min;
    }
};

/**
 * Gets the maximun zoom level of the chosen layer.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/y1xcqv4s/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @param {index} index - The index of the layer.
 * @return     {number}  The max of the level.
 */
ApiGlobe.prototype.getMaxZoomLevel = function getMaxZoomLevel(index) {
    var layer = this.getImageryLayers()[index];
    if (layer && layer.options.zoom) {
        return layer.options.zoom.max;
    } else {
        var layers = this.getImageryLayers();
        var max = 0;
        for (var i = layers.length - 1; i >= 0; i--) {
            if (layers[i].options.zoom) {
                max = Math.max(max, layers[i].options.zoom.max);
            }
        }
        return max;
    }
};

/**
 * Return the list of all layers in the scene in the order of how they are stacked on top of each other.
 * @constructor
 * @return     {layer}  The Layers.
 */
ApiGlobe.prototype.getImageryLayers = function getImageryLayers() {
    var map = this.scene.getMap();
    return map.layersConfiguration.getColorLayers();
};

/**
 * Creates the scene (the globe of iTowns).
 * The first parameter is the coordinates on wich the globe will be centered at the initialization.
 * The second one is the HTML div in wich the scene will be created.
 * @constructor
 * @param {Coords} coords.
 * @params {Div} string.
 */

ApiGlobe.prototype.createSceneGlobe = function createSceneGlobe(coordCarto, viewerDiv) {
    var _this12 = this;

    // TODO: Normalement la creation de scene ne doit pas etre ici....
    // Deplacer plus tard

    this.viewerDiv = viewerDiv;
    this.sceneLoadedDeferred = defer();

    viewerDiv.addEventListener('globe-built', function () {
        if (!sceneIsLoaded) {
            sceneIsLoaded = true;
            _this12.sceneLoadedDeferred.resolve();
            _this12.sceneLoadedDeferred = defer();
        }
    }, false);

    var gLDebug = false; // true to support GLInspector addon
    var debugMode = false;

    var coordinate = new _Coordinates.C.EPSG_4326(coordCarto.longitude, coordCarto.latitude, coordCarto.altitude);

    // FIXME: the scene is not really in EPSG:4978 atm, some axis are inverted, see
    // https://github.com/iTowns/itowns2/pull/246
    this.scene = (0, _Scene2.default)('EPSG:4978', coordinate, viewerDiv, debugMode, gLDebug);

    var map = new _Globe2.default(gLDebug);

    this.scene.add(map);

    // Register all providers
    var wmtsProvider = new _WMTS_Provider2.default({
        support: map.gLDebug
    });

    this.scene.scheduler.addProtocolProvider('wmts', wmtsProvider);
    this.scene.scheduler.addProtocolProvider('wmtsc', wmtsProvider);
    this.scene.scheduler.addProtocolProvider('tile', new _TileProvider2.default());
    this.scene.scheduler.addProtocolProvider('wms', new _WMS_Provider2.default({ support: map.gLDebug }));

    var featureProvider = new _WFS_Provider2.default();
    this.scene.scheduler.addProtocolProvider('wfs', featureProvider);
    this.scene.scheduler.addProtocolProvider('geojson', featureProvider);
    this.scene.scheduler.addProtocolProvider('kml', new _KML_Provider2.default());

    this.setSceneLoaded().then(function () {
        _this12.scene.currentControls().updateCameraTransformation();
        _this12.scene.updateScene3D();
        _this12.viewerDiv.dispatchEvent(new _customEvent2.default(INITIALIZED_EVENT));
    });

    return this.scene;
};

ApiGlobe.prototype.update = function update() {
    this.scene.notifyChange(0, true);
};

ApiGlobe.prototype.setRealisticLightingOn = function setRealisticLightingOn(value) {
    this.scene.setLightingPos();
    this.scene.getMap().setRealisticLightingOn(value);
    var lightingLayers = this.scene.getMap().layersConfiguration.lightingLayers[0];
    lightingLayers.enable = value;
    lightingLayers.position = this.scene.lightingPos;
    this.scene.browserScene.updateMaterialUniform('lightingEnabled', value);
    this.scene.renderScene3D();
};

/**
 * Sets the visibility of a layer. If the layer is not visible in the scene, this function will no effect until the camera looks at the layer.
 * @constructor
 * @param {id} string.
 * @params {visible} boolean.
 */

ApiGlobe.prototype.setLayerVisibility = function setLayerVisibility(id, visible) {
    this.scene.getMap().setLayerVisibility(id, visible);
    this.update();
    eventLayerChangedVisible.layerId = id;
    eventLayerChangedVisible.visible = visible;
    this.viewerDiv.dispatchEvent(eventLayerChangedVisible);
};

/**
 * Sets the opacity of a layer. If the layer is not visible in the scene, this function will no effect until the layer becomes visible.
 * @constructor
 * @param {id} string.
 * @params {visible} boolean.
 */

ApiGlobe.prototype.setLayerOpacity = function setLayerOpacity(id, opacity) {
    this.scene.getMap().setLayerOpacity(id, opacity);
    this.scene.renderScene3D();
    eventLayerChangedOpacity.layerId = id;
    eventLayerChangedOpacity.opacity = opacity;
    this.viewerDiv.dispatchEvent(eventLayerChangedOpacity);
};

/**
 * Returns the orientation angles of the current camera, in degrees.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/okfj460p/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 */
ApiGlobe.prototype.getCameraOrientation = function getCameraOrientation() {
    var tiltCam = this.scene.currentControls().getTilt();
    var headingCam = this.scene.currentControls().getHeading();
    return [tiltCam, headingCam];
};

/**
 * Returns the camera location projected on the ground in lat,lon.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/mjv7ha02/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @return {Position} position
 */

ApiGlobe.prototype.getCameraLocation = function getCameraLocation() {
    return _Coordinates.C.fromXYZ('EPSG:4978', this.scene.currentCamera().camera3D.position).as('EPSG:4326');
};

/**
 * Retuns the coordinates of the central point on screen.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/4tjgnv7z/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @return {Position} position
 */

ApiGlobe.prototype.getCameraTargetGeoPosition = function getCameraTargetGeoPosition() {
    return _Coordinates.C.fromXYZ('EPSG:4978', this.scene.currentControls().getCameraTargetPosition()).as('EPSG:4326');
};

/**
 * Sets orientation angles of the current camera, in degrees.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/9qr2mogh/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @param      {object}   orientation  The angle of the rotation in degrees
 * @param      {boolean}  isAnimated   Indicates if animated
 * @return     {Promise}   { description_of_the_return_value }
 */
ApiGlobe.prototype.setCameraOrientation = function setCameraOrientation(orientation, isAnimated) {
    var _this13 = this;

    return this.scene.currentControls().setOrbitalPosition(undefined, orientation.heading, orientation.tilt, isAnimated).then(function () {
        _this13.viewerDiv.dispatchEvent(eventOrientation);
    });
};

/**
 * Pick a position on the globe at the given position.
 * @constructor
 * @param {number | MouseEvent} x|event - The x-position inside the Globe element or a mouse event.
 * @param {number | undefined} y - The y-position inside the Globe element.
 * @return {Position} position
 */
ApiGlobe.prototype.pickPosition = function pickPosition(mouse, y) {
    var screenCoords = {
        x: mouse.clientX || mouse,
        y: mouse.clientY || y
    };

    var pickedPosition = this.scene.getPickPosition(screenCoords);

    this.scene.renderScene3D();

    if (!pickedPosition) {
        return;
    }

    return _Coordinates.C.fromXYZ('EPSG:4978', pickedPosition).as('EPSG:4326');
};

/**
 * Returns the tilt in degrees.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/kcx0of9j/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @return {Angle} number - The angle of the rotation in degrees.
 */

ApiGlobe.prototype.getTilt = function getTilt() {
    var tiltCam = this.scene.currentControls().getTilt();
    return tiltCam;
};

/**
 * Returns the heading in degrees.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/pxv1Lw16/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @return {Angle} number - The angle of the rotation in degrees.
 */

ApiGlobe.prototype.getHeading = function getHeading() {
    var headingCam = this.scene.currentControls().getHeading();
    return headingCam;
};

/**
 * Returns the "range": the distance in meters between the camera and the current central point on the screen.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/Lbt1vfek/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @return {number} number
 */

ApiGlobe.prototype.getRange = function getRange() {
    return this.scene.currentControls().getRange();
};

ApiGlobe.prototype.getRangeFromEllipsoid = function getRangeFromEllipsoid() {
    // TODO: error is distance is big with ellipsoid.intersection(ray) because d < 0
    var controlCam = this.scene.currentControls();
    var ellipsoid = this.scene.getEllipsoid();
    var ray = controlCam.getRay();
    var intersection = ellipsoid.intersection(ray);
    var camPosition = this.scene.currentCamera().position();
    var range = intersection.distanceTo(camPosition);

    return range;
};

/**
 * Sets the animation enabled.
 * @constructor
 * @param      {boolean}  enable  The enable
 */
ApiGlobe.prototype.setAnimationEnabled = function setAnimationEnabled(enable) {
    enableAnimation = enable;
};

/**
 * Determines if animation enabled.
 *
 * @return     {boolean}  True if animation enabled, False otherwise.
 */
ApiGlobe.prototype.isAnimationEnabled = function isAnimationEnabled() {
    return enableAnimation;
};

/**
 * Change the tilt.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/p6t76zox/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @param {Angle} Number - The angle.
 * @param      {boolean}  isAnimated  Indicates if animated
 * @return     {Promise}
 */
ApiGlobe.prototype.setTilt = function setTilt(tilt, isAnimated) {
    var _this14 = this;

    isAnimated = isAnimated || this.isAnimationEnabled();
    eventOrientation.oldTilt = this.getTilt();
    return this.scene.currentControls().setTilt(tilt, isAnimated).then(function () {
        _this14.viewerDiv.dispatchEvent(eventOrientation);
        _this14.scene.notifyChange(1);
    });
};

/**
 * Change the heading.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/rxe4xgxj/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @param {Angle} Number - The angle.
 * @param      {boolean}  isAnimated  Indicates if animated
 * @return     {Promise}
 */
ApiGlobe.prototype.setHeading = function setHeading(heading, isAnimated) {
    var _this15 = this;

    isAnimated = isAnimated || this.isAnimationEnabled();
    eventOrientation.oldHeading = this.getHeading();
    return this.scene.currentControls().setHeading(heading, isAnimated).then(function () {
        _this15.viewerDiv.dispatchEvent(eventOrientation);
        _this15.scene.notifyChange(1);
    });
};

/**
 * Resets camera tilt -> sets the tilt to 0°.
 * @constructor
 * @param      {boolean}  isAnimated  Indicates if animated
 * @return     {Promise}
 */
ApiGlobe.prototype.resetTilt = function resetTilt(isAnimated) {
    isAnimated = isAnimated || this.isAnimationEnabled();
    return this.scene.currentControls().setTilt(0, isAnimated);
};

/**
 * Resets camera heading -> sets the heading to 0°.
 * @constructor
 * @param      {boolean}  isAnimated  Indicates if animated
 * @return     {Promise}
 */
ApiGlobe.prototype.resetHeading = function resetHeading(isAnimated) {
    isAnimated = isAnimated || this.isAnimationEnabled();
    return this.scene.currentControls().setHeading(0, isAnimated);
};

/**
 * Returns the distance in meter between two geographic positions.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/0nLhws5u/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @param {Position} First - Position.
 * @param {Position} Second - Position.
 * @return {Number} distance
 */

ApiGlobe.prototype.setSceneLoaded = function setSceneLoaded() {
    sceneIsLoaded = false;
    return this.sceneLoadedDeferred.promise;
};

/**
 * Changes the center of the scene on screen to the specified coordinates.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/x06yhbq6/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @param {Object} coordinates - The globe coordinates in EPSG_4326 projection to aim to
 * @param {number} coordinates.latitude
 * @param {number} coordinates.longitude
 * @param {number} coordinates.range
 * @param {boolean}  isAnimated - if the movement should be animated
 * @return {Promise} A promise that resolves when the next 'globe-loaded' event fires.
 */
ApiGlobe.prototype.setCameraTargetGeoPosition = function setCameraTargetGeoPosition(coordinates, isAnimated) {
    var _this16 = this;

    isAnimated = isAnimated || this.isAnimationEnabled();
    var position3D = new _Coordinates.C.EPSG_4326(coordinates.longitude, coordinates.latitude, 0).as('EPSG:4978').xyz();
    position3D.range = coordinates.range;
    return this.scene.currentControls().setCameraTargetPosition(position3D, isAnimated).then(function () {
        _this16.scene.notifyChange(1);
        return _this16.setSceneLoaded().then(function () {
            _this16.scene.currentControls().updateCameraTransformation();
        });
    });
};

/**
 * Changes the center of the scene on screen to the specified coordinates.
 * This function allows to change the central position, the zoom level, the range, the scale and the camera orientation at the same time.
 * The level has to be between the [getMinZoomLevel(), getMaxZoomLevel()].
 * The zoom level and the scale can't be set at the same time.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/7yk0mpn0/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @param {Position} position
 * @param {number}  position.longitude  Coordinate longitude WGS84 in degree
 * @param {number}  position.latitude  Coordinate latitude WGS84 in degree
 * @param {number}  [position.tilt]  Camera tilt in degree
 * @param {number}  [position.heading]  Camera heading in degree
 * @param {number}  [position.range]  The camera distance to the target center
 * @param {number}  [position.level]  level,  ignored if range is set
 * @param {number}  [position.scale]  scale,  ignored if the zoom level or range is set. For a scale of 1/500 it is necessary to write 0,002.
 * @param {boolean}  isAnimated  Indicates if animated
 * @return {Promise}
 */
ApiGlobe.prototype.setCameraTargetGeoPositionAdvanced = function setCameraTargetGeoPositionAdvanced(position, isAnimated) {
    var _this17 = this;

    isAnimated = isAnimated || this.isAnimationEnabled();
    if (position.level) {
        position.range = this.getRangeFromZoomLevel(position.level);
    } else if (position.scale) {
        position.range = this.getRangeFromScale(position.scale);
    }
    return this.setCameraTargetGeoPosition(position, isAnimated).then(function () {
        position.range = position.range || _this17.getRange();
        position.tilt = position.tilt || _this17.getTilt();
        position.heading = position.heading || _this17.getHeading();
        return _this17.scene.currentControls().setOrbitalPosition(position.range, position.heading, position.tilt, isAnimated).then(function () {
            _this17.scene.notifyChange(1);
            return _this17.setSceneLoaded().then(function () {
                _this17.scene.currentControls().updateCameraTransformation();
            });
        });
    });
};

/**
 * Sets the "range": the distance in meters between the camera and the current central point on the screen.
 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/Lt3jL5pd/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
 * @constructor
 * @param {Number} pRange - The camera altitude.
 * @param      {boolean}  isAnimated  Indicates if animated
 * @return     {Promise}
 */
ApiGlobe.prototype.setRange = function setRange(pRange, isAnimated) {
    var _this18 = this;

    isAnimated = isAnimated || this.isAnimationEnabled();
    eventRange.oldRange = this.getRange();

    return this.scene.currentControls().setRange(pRange, isAnimated).then(function () {
        _this18.scene.notifyChange(1);
        return _this18.setSceneLoaded().then(function () {
            _this18.scene.currentControls().updateCameraTransformation();
            _this18.viewerDiv.dispatchEvent(eventRange);
        });
    });
};

/**
 * Displaces the central point to a specific amount of pixels from its current position.
 * The view flies to the desired coordinate, i.e.is not teleported instantly. Note : The results can be strange in some cases, if ever possible, when e.g.the camera looks horizontally or if the displaced center would not pick the ground once displaced.
 * @constructor
 * @param      {vector}  pVector  The vector
 */
ApiGlobe.prototype.pan = function pan(pVector) {
    var _this19 = this;

    this.scene.currentControls().pan(pVector.x, pVector.y);
    this.scene.notifyChange(1);
    this.setSceneLoaded().then(function () {
        _this19.scene.currentControls().updateCameraTransformation();
        _this19.viewerDiv.dispatchEvent(eventPan);
    });
};

/**
 * Returns the actual zoom level. The level will always be between the [getMinZoomLevel(), getMaxZoomLevel()].
 * @constructor
 * @return     {number}  The zoom level.
 */
ApiGlobe.prototype.getZoomLevel = function getZoomLevel() {
    return this.scene.getMap().getZoomLevel();
};

/**
 * Gets the current zoom level, which is an index in the logical scales predefined for the application.
 * The higher the level, the closer to the ground.
 * The level is always in the [getMinZoomLevel(), getMaxZoomLevel()] range.
 * @constructor
 * @param      {number}  zoom    The zoom
 * @param      {boolean}  isAnimated  Indicates if animated
 * @return     {Promise}
 */
ApiGlobe.prototype.setZoomLevel = function setZoomLevel(zoom, isAnimated) {
    var range = this.getRangeFromZoomLevel(zoom);
    return this.setRange(range, isAnimated);
};

ApiGlobe.prototype.getRangeFromZoomLevel = function getRangeFromZoomLevel(zoom) {
    // FIXME : The distance computed is incorrect, (Fixed in PR 279)
    var range = this.scene.getMap().computeDistanceForZoomLevel(zoom, this.scene.currentCamera());
    return range;
};

/**
 * Return the current zoom scale at the central point of the view.
 * This function compute the scale of a map
 * @constructor
 * @param      {number}  pitch   Screen pitch, in millimeters ; 0.28 by default
 * @return     {number}  The zoom scale.
 */
ApiGlobe.prototype.getZoomScale = function getZoomScale(pitch) {
    // TODO: Why error div size height in Chrome?
    // Screen pitch, in millimeters
    pitch = (pitch || 0.28) / 1000;

    // To compute scale, we must to calculate the maximum vertical distance (in meter) perceived by the camera
    // the maximum vertical distance 2xHS (look at the explanations below 'HS segment')
    // There's two state
    //     * Globe is inside the frustrum camera
    //     * Globe intersects with the frustrum camera
    var camera = this.scene.currentCamera();
    var center = this.scene.currentControls().getCameraTargetPosition();
    var rayon = center.length();
    var range = center.distanceTo(camera.camera3D.position);
    // compute distance camera/globe's center
    var distance = rayon + range;
    // Three points C,G and S
    // C : Camera's position
    // G : Globe's center
    // S : The furthest interesection[camera verical frustrum, globe surface] from line CG
    // HS is triangle CSG's altitude going through S and H is in GC segment
    // alpha is angle GCS
    // phi is angle CSG
    var alpha = camera.FOV / 180 * Math.PI * 0.5;
    var phi = Math.PI - Math.asin(distance / rayon * Math.sin(alpha));
    // projection is projection segment HS on camera
    var projection = void 0;

    if (isNaN(phi)) {
        // Globe is inside the frustrum camera
        projection = distance * 2 * Math.tan(alpha);
    } else {
        // Globe intersects with the frustrum camera

        // develop operation
        // {
        //     var beta = Math.PI - ( phi + alpha);
        //     projection = rayon * Math.sin(beta) * 2.0;
        // }
        // factorisation ->
        projection = 2.0 * rayon * Math.sin(phi + alpha);
    }

    var zoomScale = camera.height * pitch / projection;

    return zoomScale;
};

/**
 * Changes the zoom level of the central point of screen so that screen acts as a map with a specified scale.
 *  The view flies to the desired zoom scale;
 * @constructor
 * @param      {number}  zoomScale  The zoom scale
 * @param      {number}  pitch      The pitch
 * @param      {boolean}  isAnimated  Indicates if animated
 * @return     {Promise}
 */
ApiGlobe.prototype.setZoomScale = function setZoomScale(zoomScale, pitch, isAnimated) {
    var range = this.getRangeFromScale(zoomScale);
    return this.setRange(range, isAnimated);
};

ApiGlobe.prototype.getRangeFromScale = function getRangeFromScale(zoomScale, pitch) {
    // Screen pitch, in millimeters
    pitch = (pitch || 0.28) / 1000;

    // To set scale, we must to calculate the maximum vertical distance (in meter) perceived by the camera
    // the maximum vertical distance 2xHS (look at the explanations below 'HS segment')
    // projection is projection segment HS on camera
    // There's two state
    //     * Globe is inside the frustrum camera
    //     * Globe intersects with the frustrum camera

    var camera = this.scene.currentCamera();
    var projection = camera.height * pitch / zoomScale;
    var rayon = this.scene.currentControls().getCameraTargetPosition().length();
    var alpha = camera.FOV / 180 * Math.PI * 0.5;
    // distance camera/globe's center
    var distance = void 0;
    // Three points C,G and S
    // C camera's position
    // G globe's center
    // S = the furthest interesection[camera verical frustrum, globe surface] from line CG
    // HS is triangle CSG's altitude going through S and H is in GC segment
    // alpha is angle GCS
    // phi is angle CSG
    // beta is angle SGC
    var sinBeta = projection / (2 * rayon);

    if (sinBeta < 1.0) {
        // Globe is inside the frustrum camera
        var beta = Math.asin(sinBeta);
        // develop operation
        //  {
        //      let phi = Math.PI - ( beta + alpha);
        //      distance  = rayon * Math.sin(phi) / Math.sin(alpha) ;
        //  }
        //  factorisation ->
        distance = rayon * Math.sin(beta + alpha) / Math.sin(alpha);
    } else {
        // Globe is inside the frustrum camera
        distance = rayon / Math.tan(alpha) * sinBeta;
    }

    var range = distance - rayon;
    return range;
};

/**
 * Some event return the old value before the change. The available events are centerchanged, zoomchanged, orientationchanged, layerchanged:opacity, layerchanged:visible, layerchanged:ipr and layerchanged:index.
 * @constructor
 * @param {string} Eventname - The name of the event.
 * @param {callback} Callback - The callback that is called when the event is heard.
 */

ApiGlobe.prototype.addEventListener = function addEventListenerProto(eventname, callback) {
    if (eventname == 'layerchanged') {
        this.viewerDiv.addEventListener('layerchanged', callback, false);
        this.addEventListenerLayerChanged();
    } else {
        this.viewerDiv.addEventListener(eventname, callback, false);
    }
};

ApiGlobe.prototype.addEventListenerLayerChanged = function addEventListenerLayerChanged() {
    this.viewerDiv.addEventListener('layerchanged:visible', this.callbackLayerChanged, false);
    this.viewerDiv.addEventListener('layerchanged:opacity', this.callbackLayerChanged, false);
    this.viewerDiv.addEventListener('layerchanged:index', this.callbackLayerChanged, false);
};

ApiGlobe.prototype.callbackLayerChanged = function callbackLayerChanged() {
    this.dispatchEvent(eventLayerChanged);
};

/**
 * Remove the event of events listener from the event target.
 * @constructor
 * @param {string} Eventname - The name of the event.
 * @param {callback} Callback - The callback that is called when the event is heard.
 */

ApiGlobe.prototype.removeEventListener = function removeEventListenerProto(eventname, callback) {
    if (eventname == 'layerchanged') {
        this.viewerDiv.removeEventListener('layerchanged', callback, false);
        this.removeEventListenerLayerChanged();
    } else {
        this.viewerDiv.removeEventListener(eventname, callback, false);
    }
};

ApiGlobe.prototype.removeEventListenerLayerChanged = function removeEventListenerLayerChanged() {
    this.viewerDiv.removeEventListener('layerchanged:visible', this.callbackLayerChanged, false);
    this.viewerDiv.removeEventListener('layerchanged:opacity', this.callbackLayerChanged, false);
    this.viewerDiv.removeEventListener('layerchanged:index', this.callbackLayerChanged, false);
};

/**
 * Get the Attribution of all layers in the scene.
 * @return {map}  A Map of attribution.
 */

ApiGlobe.prototype.getLayersAttribution = function getLayersAttribution() {
    var lc = this.scene.getMap().layersConfiguration;
    var map = new _map2.default();
    [].concat((0, _toConsumableArray3.default)(lc.getColorLayers()), (0, _toConsumableArray3.default)(lc.getElevationLayers())).forEach(function (l) {
        if (l.options.attribution) {
            map.set(l.options.attribution.name, l.options.attribution);
        }
    });
    return map;
};

/**
 * Return all the layers in the scene.
 * The type can be 'color', 'elevation' and 'geometry'. If the type is not specified, the function return all the layers.
 * @param {type} Type - The type of the layers wanted.
 */

ApiGlobe.prototype.getLayers = function getLayers(type) {
    var lc = this.scene.getMap().layersConfiguration;
    if (!type) {
        return lc.getLayers();
    } else if (type === 'color') {
        return lc.getColorLayers();
    } else if (type === 'elevation') {
        return lc.getElevationLayers();
    } else if (type === 'geometry') {
        return lc.getGeometryLayers();
    }
};

/**
 * Return a layer by its id.
 * @param {id} ID - The id of the layer wanted.
 */

ApiGlobe.prototype.getLayerById = function getLayerById(pId) {
    var lc = this.scene.getMap().layersConfiguration.getLayers();
    return lc.find(function (l) {
        return l.id === pId;
    });
};

ApiGlobe.prototype.loadGPX = function loadGPX(url) {
    var _this20 = this;

    (0, _GpxUtils2.default)(url).then(function (gpx) {
        if (gpx) {
            _this20.scene.getMap().gpxTracks.children[0].add(gpx);
        }
    });

    this.scene.renderScene3D();
};

ApiGlobe.prototype.addFeature = function addFeature(options) {
    if (options === undefined) {
        throw new Error('options is required');
    }
    var map = this.scene.getMap();
    var layer = map.layersConfiguration.getGeometryLayerById(options.layerId);
    if (options.type && layer) {
        var tools = this.scene.scheduler.getProtocolProvider('wfs').featureToolBox;
        var featureMesh = tools.processingGeoJSON(options);
        layer.root.add(featureMesh);
    }
};

ApiGlobe.prototype.pickFeature = function pickFeature(position, layerId) {
    if (position == undefined) {
        throw new Error('position is required');
    }
    var map = this.scene.getMap();
    var layer = map.layersConfiguration.getGeometryLayerById(layerId);
    return this.scene.gfxEngine.getPickObject3d(position, layer.root.children);
};

ApiGlobe.prototype.removeFeature = function removeFeature(feature) {
    var featureId = feature.featureId;
    var layerId = feature.layerId;
    var map = this.scene.getMap();
    var layer = map.layersConfiguration.getGeometryLayerById(layerId);
    // FIXME: don't work?
    layer.root.children.splice(featureId, 1);
};

exports.default = ApiGlobe;