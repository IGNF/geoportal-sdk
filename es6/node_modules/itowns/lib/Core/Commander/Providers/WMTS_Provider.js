'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _CoordWMTS = require('../../Geographic/CoordWMTS');

var _CoordWMTS2 = _interopRequireDefault(_CoordWMTS);

var _OGCWebServiceHelper = require('./OGCWebServiceHelper');

var _OGCWebServiceHelper2 = _interopRequireDefault(_OGCWebServiceHelper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WMTS_WGS84Parent = function WMTS_WGS84Parent(cWMTS, levelParent, pitch) {
    var diffLevel = cWMTS.zoom - levelParent;
    var diff = Math.pow(2, diffLevel);
    var invDiff = 1 / diff;

    var r = (cWMTS.row - cWMTS.row % diff) * invDiff;
    var c = (cWMTS.col - cWMTS.col % diff) * invDiff;

    pitch.x = cWMTS.col * invDiff - c;
    pitch.y = cWMTS.row * invDiff - r;
    pitch.z = invDiff;

    return new _CoordWMTS2.default(levelParent, r, c);
}; /**
    * Generated On: 2015-10-5
    * Class: WMTS_Provider
    * Description: Fournisseur de données à travers un flux WMTS
    */

function WMTS_Provider() {}

WMTS_Provider.prototype.customUrl = function customUrl(layer, url, tilematrix, row, col) {
    var urld = url.replace('%TILEMATRIX', tilematrix.toString());
    urld = urld.replace('%ROW', row.toString());
    urld = urld.replace('%COL', col.toString());

    return urld;
};

WMTS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {
    layer.fx = layer.fx || 0.0;
    if (layer.protocol === 'wmtsc') {
        layer.options.zoom = {
            min: 2,
            max: 20
        };
    } else {
        var options = layer.options;
        options.version = options.version || '1.0.0';
        options.tileMatrixSet = options.tileMatrixSet || 'WGS84';
        options.mimetype = options.mimetype || 'image/png';
        options.style = options.style || 'normal';
        options.projection = options.projection || 'EPSG:3857';
        var newBaseUrl = layer.url + '?LAYER=' + options.name + '&FORMAT=' + options.mimetype + '&SERVICE=WMTS' + '&VERSION=1.0.0' + ('&REQUEST=GetTile&STYLE=normal&TILEMATRIXSET=' + options.tileMatrixSet);

        newBaseUrl += '&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL';

        if (!layer.options.zoom && options.tileMatrixSetLimits) {
            var arrayLimits = (0, _keys2.default)(options.tileMatrixSetLimits);
            var size = arrayLimits.length;
            var maxZoom = Number(arrayLimits[size - 1]);
            var minZoom = maxZoom - size + 1;

            layer.options.zoom = {
                min: minZoom,
                max: maxZoom
            };
        } else {
            layer.options.zoom = {
                min: 2,
                max: 20
            };
        }
        layer.customUrl = newBaseUrl;
    }
};

/**
 * Return url wmts orthophoto
 * @param {type} coWMTS
 * @returns {Object@call;create.urlOrtho.url|String}
 */
WMTS_Provider.prototype.url = function url(coWMTS, layer) {
    return this.customUrl(layer, layer.customUrl, coWMTS.zoom, coWMTS.row, coWMTS.col);
};

/**
 * return texture float alpha THREE.js of MNT
 * @param {type} coWMTS : coord WMTS
 * @returns {WMTS_Provider_L15.WMTS_Provider.prototype@pro;_IoDriver@call;read@call;then}
 */
WMTS_Provider.prototype.getXbilTexture = function getXbilTexture(tile, layer, targetZoom) {
    var pitch = new THREE.Vector3(0.0, 0.0, 1.0);
    var coordWMTS = tile.wmtsCoords[layer.options.tileMatrixSet][0];

    if (targetZoom && targetZoom !== coordWMTS.zoom) {
        coordWMTS = WMTS_WGS84Parent(coordWMTS, targetZoom, pitch);
    }

    var url = this.url(coordWMTS, layer);

    return _OGCWebServiceHelper2.default.getXBilTextureByUrl(url).then(function (result) {
        var _OGCWebServiceHelper$ = _OGCWebServiceHelper2.default.ioDXBIL.computeMinMaxElevation(result.texture.image.data, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, pitch),
            min = _OGCWebServiceHelper$.min,
            max = _OGCWebServiceHelper$.max;

        result.min = min === undefined ? 0 : min;
        result.max = max === undefined ? 0 : max;
        result.texture.coordWMTS = coordWMTS;
        result.pitch = pitch;
        return result;
    });
};

/**
 * Return texture RGBA THREE.js of orthophoto
 * TODO : RGBA --> RGB remove alpha canal
 * @param {type} coordWMTS
 * @param {type} id
 * @returns {WMTS_Provider_L15.WMTS_Provider.prototype@pro;ioDriverImage@call;read@call;then}
 */
WMTS_Provider.prototype.getColorTexture = function getColorTexture(coordWMTS, layer) {
    var url = this.url(coordWMTS, layer);
    return _OGCWebServiceHelper2.default.getColorTextureByUrl(url).then(function (texture) {
        var result = {};
        result.texture = texture;
        result.texture.coordWMTS = coordWMTS;
        result.pitch = new THREE.Vector3(0, 0, 1);

        return result;
    });
};

WMTS_Provider.prototype.executeCommand = function executeCommand(command) {
    var layer = command.layer;
    var tile = command.requester;

    var supportedFormats = {
        'image/png': this.getColorTextures.bind(this),
        'image/jpg': this.getColorTextures.bind(this),
        'image/jpeg': this.getColorTextures.bind(this),
        'image/x-bil;bits=32': this.getXbilTexture.bind(this)
    };

    var func = supportedFormats[layer.options.mimetype];
    if (func) {
        return func(tile, layer, command.targetLevel);
    } else {
        return _promise2.default.reject(new Error('Unsupported mimetype ' + layer.options.mimetype));
    }
};

WMTS_Provider.prototype.tileTextureCount = function tileTextureCount(tile, layer) {
    var tileMatrixSet = layer.options.tileMatrixSet;
    return tile.wmtsCoords[tileMatrixSet][1].row - tile.wmtsCoords[tileMatrixSet][0].row + 1;
};

WMTS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer) {
    // This layer provides data starting at level = layer.options.zoom.min
    // (the zoom.max property is used when building the url to make
    //  sure we don't use invalid levels)
    return layer.options.zoom.min <= tile.wmtsCoords[layer.options.tileMatrixSet][0].zoom; // && tile.level <= layer.zoom.max;
};

WMTS_Provider.prototype.getColorTextures = function getColorTextures(tile, layer) {
    if (tile.material === null) {
        return _promise2.default.resolve();
    }
    var promises = [];
    var bcoord = tile.wmtsCoords[layer.options.tileMatrixSet];

    for (var row = bcoord[1].row; row >= bcoord[0].row; row--) {
        var coordWMTS = new _CoordWMTS2.default(bcoord[0].zoom, row, bcoord[0].col);
        promises.push(this.getColorTexture(coordWMTS, layer));
    }

    return _promise2.default.all(promises);
};

exports.default = WMTS_Provider;