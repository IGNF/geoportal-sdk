'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SIZE_TEXTURE_TILE = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _Fetcher = require('./Fetcher');

var _Fetcher2 = _interopRequireDefault(_Fetcher);

var _CacheRessource = require('./CacheRessource');

var _CacheRessource2 = _interopRequireDefault(_CacheRessource);

var _IoDriver_XBIL = require('./IoDriver_XBIL');

var _IoDriver_XBIL2 = _interopRequireDefault(_IoDriver_XBIL);

var _Projection = require('../../Geographic/Projection');

var _Projection2 = _interopRequireDefault(_Projection);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SIZE_TEXTURE_TILE = exports.SIZE_TEXTURE_TILE = 256;

// CacheRessource is necessary for neighboring PM textures
// The PM textures overlap several tiles WGS84, it is to avoid net requests
// Info : THREE.js have cache image https://github.com/mrdoob/three.js/blob/master/src/loaders/ImageLoader.js#L25
var cache = (0, _CacheRessource2.default)();
var cachePending = new _map2.default();
var ioDXBIL = new _IoDriver_XBIL2.default();
var projection = new _Projection2.default();

var getTextureFloat = function getTextureFloat(buffer) {
    var texture = new THREE.DataTexture(buffer, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, THREE.AlphaFormat, THREE.FloatType);
    texture.needsUpdate = true;
    return texture;
};

exports.default = {
    ioDXBIL: ioDXBIL,
    getColorTextureByUrl: function getColorTextureByUrl(url) {
        var cachedTexture = cache.getRessource(url);

        if (cachedTexture) {
            return _promise2.default.resolve(cachedTexture);
        }

        var _Fetcher$texture = _Fetcher2.default.texture(url),
            texture = _Fetcher$texture.texture,
            promise = _Fetcher$texture.promise;

        texture.generateMipmaps = false;
        texture.magFilter = THREE.LinearFilter;
        texture.minFilter = THREE.LinearFilter;
        texture.anisotropy = 16;

        return promise.then(function () {
            if (!cache.getRessource(url)) {
                cache.addRessource(url, texture);
            }
            return texture;
        });
    },
    getXBilTextureByUrl: function getXBilTextureByUrl(url) {
        var textureCache = cache.getRessource(url);

        if (textureCache !== undefined) {
            return _promise2.default.resolve({ texture: textureCache });
        }

        var promiseXBil = (cachePending.get(url) || ioDXBIL.read(url)).then(function (result) {
            // TODO  RGBA is needed for navigator with no support in texture float
            // In RGBA elevation texture LinearFilter give some errors with nodata value.
            // need to rewrite sample function in shader

            // loading concurrence
            var textureConcurrence = cache.getRessource(url);
            if (textureConcurrence) {
                cachePending.delete(url);
                return textureConcurrence;
            }

            result.texture = getTextureFloat(result.floatArray);
            result.texture.generateMipmaps = false;
            result.texture.magFilter = THREE.LinearFilter;
            result.texture.minFilter = THREE.LinearFilter;
            cache.addRessource(url, result.texture);
            cachePending.delete(url);

            return result;
        });

        cachePending.set(url, promiseXBil);

        return promiseXBil;
    },
    computeTileMatrixSetCoordinates: function computeTileMatrixSetCoordinates(tile, tileMatrixSet) {
        // Are WMTS coordinates ready?
        if (!tile.wmtsCoords) {
            tile.wmtsCoords = {};
        }

        tileMatrixSet = tileMatrixSet || 'WGS84G';
        if (!(tileMatrixSet in tile.wmtsCoords)) {
            var tileCoord = projection.WGS84toWMTS(tile.bbox);

            tile.wmtsCoords[tileMatrixSet] = projection.getCoordWMTS_WGS84(tileCoord, tile.bbox, tileMatrixSet);
        }
    }
};