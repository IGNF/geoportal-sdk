'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _BoundingBox = require('../../../Scene/BoundingBox');

var _BoundingBox2 = _interopRequireDefault(_BoundingBox);

var _OGCWebServiceHelper = require('./OGCWebServiceHelper');

var _OGCWebServiceHelper2 = _interopRequireDefault(_OGCWebServiceHelper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Return url wmts MNT
 * @param {String} options.url: service base url
 * @param {String} options.layer: requested data layer
 * @param {String} options.format: image format (default: format/jpeg)
 * @returns {Object@call;create.url.url|String}
 */
function WMS_Provider() {} /**
                            * Generated On: 2015-10-5
                            * Class: WMS_Provider
                            * Description: Provides data from a WMS stream
                            */

WMS_Provider.prototype.url = function url(bbox, layer) {
    var box = bbox.as(layer.projection);
    var v = [box.west(), box.south(), box.east(), box.north()];
    var bboxInUnit = layer.bbox_url === 'swne' ? v[1] + ',' + v[0] + ',' + v[3] + ',' + v[2] : v[0] + ',' + v[1] + ',' + v[2] + ',' + v[3];

    return layer.customUrl.replace('%bbox', bboxInUnit);
};

WMS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {
    if (!layer.name) {
        throw new Error('layerName is required.');
    }
    if (!layer.bbox) {
        throw new Error('bbox is required');
    }
    if (!layer.projection) {
        throw new Error('projection is required');
    }

    layer.bbox = new _BoundingBox2.default(layer.projection, layer.bbox[0], layer.bbox[1], layer.bbox[2], layer.bbox[3]);

    layer.bbox_url = layer.bbox_url || 'swne';
    layer.format = layer.options.mimetype || 'image/png';
    layer.width = layer.heightMapWidth || 256;
    layer.version = layer.version || '1.3.0';
    layer.style = layer.style || '';
    layer.transparent = layer.transparent || false;

    layer.customUrl = layer.url + '?SERVICE=WMS&REQUEST=GetMap&LAYERS=' + layer.name + '&VERSION=' + layer.version + '&STYLES=' + layer.style + '&FORMAT=' + layer.format + '&TRANSPARENT=' + layer.transparent + '&BBOX=%bbox' + ('&CRS=' + layer.projection + '&WIDTH=' + layer.width + '&HEIGHT=' + layer.width);
};

WMS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer) {
    return tile.level > 2 && layer.bbox.intersect(tile.bbox);
};

WMS_Provider.prototype.getColorTexture = function getColorTexture(tile, layer) {
    if (!this.tileInsideLimit(tile, layer) || tile.material === null) {
        return _promise2.default.resolve();
    }

    var url = this.url(tile.bbox.as(layer.projection), layer);
    var pitch = new THREE.Vector3(0, 0, 1);
    var result = { pitch: pitch };

    return _OGCWebServiceHelper2.default.getColorTextureByUrl(url).then(function (texture) {
        result.texture = texture;
        result.texture.bbox = tile.bbox;
        return result;
    });
};

WMS_Provider.prototype.getXbilTexture = function getXbilTexture(tile, layer) {
    var url = this.url(tile.bbox.as(layer.projection), layer);
    return this.getXBilTextureByUrl(url, new THREE.Vector3(0, 0, 1));
};

WMS_Provider.prototype.executeCommand = function executeCommand(command) {
    var tile = command.requester;

    var layer = command.layer;
    var supportedFormats = {
        'image/png': this.getColorTexture.bind(this),
        'image/jpg': this.getColorTexture.bind(this),
        'image/jpeg': this.getColorTexture.bind(this),
        'image/x-bil;bits=32': this.getXbilTexture.bind(this)
    };

    var func = supportedFormats[layer.format];

    if (func) {
        return func(tile, layer);
    } else {
        return _promise2.default.reject(new Error('Unsupported mimetype ' + layer.format));
    }
};

exports.default = WMS_Provider;