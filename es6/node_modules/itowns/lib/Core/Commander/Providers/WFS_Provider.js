'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _Provider = require('./Provider');

var _Provider2 = _interopRequireDefault(_Provider);

var _Fetcher = require('./Fetcher');

var _Fetcher2 = _interopRequireDefault(_Fetcher);

var _CacheRessource = require('./CacheRessource');

var _CacheRessource2 = _interopRequireDefault(_CacheRessource);

var _BoundingBox = require('../../../Scene/BoundingBox');

var _BoundingBox2 = _interopRequireDefault(_BoundingBox);

var _FeatureToolBox = require('../../../Renderer/ThreeExtented/FeatureToolBox');

var _FeatureToolBox2 = _interopRequireDefault(_FeatureToolBox);

var _NodeMesh = require('../../../Renderer/NodeMesh');

var _NodeMesh2 = _interopRequireDefault(_NodeMesh);

var _Layer = require('../../../Scene/Layer');

var _Layer2 = _interopRequireDefault(_Layer);

var _Coordinates = require('../../Geographic/Coordinates');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Return url wmts MNT
 * @param {String} options.url: service base url
 * @param {String} options.layer: requested data layer
 * @param {String} options.format: image format (default: format/jpeg)
 * @returns {Object@call;create.url.url|String}
 * */

/**
 * Generated On: 2016-03-5
 * Class: WFS_Provider
 * Description: Provides data from a WFS stream
 */

function WFS_Provider(options) {
    options = options || {};
    this.cache = (0, _CacheRessource2.default)();
    this.baseUrl = options.url || '';
    this.layer = options.layer || '';
    this.typename = options.typename || '';
    this.format = options.format === undefined ? 'json' : options.format;
    this.epsgCode = options.epsgCode || 4326;
    this.batiments = [];
    this.pointOrder = new _map2.default();
    this.featureToolBox = new _FeatureToolBox2.default(options.ellipsoid);
}

WFS_Provider.prototype = (0, _create2.default)(_Provider2.default.prototype);
WFS_Provider.prototype.constructor = WFS_Provider;

WFS_Provider.prototype.url = function url(coord, layer) {
    var bbox = void 0;
    if (layer.axisOrder == 'ordered') {
        bbox = coord.south(_Coordinates.UNIT.DEGREE) + ',' + coord.west(_Coordinates.UNIT.DEGREE) + ',' + coord.north(_Coordinates.UNIT.DEGREE) + ',' + coord.east(_Coordinates.UNIT.DEGREE);
    } else {
        bbox = coord.west(_Coordinates.UNIT.DEGREE) + ',' + coord.south(_Coordinates.UNIT.DEGREE) + ',' + coord.east(_Coordinates.UNIT.DEGREE) + ',' + coord.north(_Coordinates.UNIT.DEGREE);
    }
    return layer.customUrl.replace('%bbox', bbox.toString());
};

WFS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {
    if (!layer.title) {
        throw new Error('layerName is required.');
    }
    // if (!layer.projection) {
    //     throw new Error('projection is required');
    // }
    // if (!layer.bbox) {
    //     throw new Error('bbox is required');
    // }
    layer.projection = layer.projection || 'EPSG:4326';
    layer.bbox = layer.bbox || [-180, -90, 90, 180];
    layer.bbox = new _BoundingBox2.default(layer.projection, layer.bbox[0], layer.bbox[2], layer.bbox[1], layer.bbox[3]);

    layer.root = new _NodeMesh2.default();
    var featureLayer = new _Layer2.default();
    featureLayer.add(layer.root);
    if (layer.protocol === 'geojson') {
        layer.format = 'geojson';
    } else {
        layer.format = layer.options.mimetype || 'json';
    }
    layer.crs = layer.projection || 'EPSG:4326';
    layer.version = layer.version || '1.3.0';
    layer.customUrl = layer.url + 'SERVICE=WFS&REQUEST=GetFeature&typeName=' + layer.title + '&VERSION=' + layer.version + '&SRSNAME=' + layer.crs + '&outputFormat=' + layer.format + '&BBOX=%bbox,' + layer.crs;
};

WFS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer) {
    return tile.level === 16 && layer.bbox.intersect(tile.bbox);
};

WFS_Provider.prototype.executeCommand = function executeCommand(command) {
    var layer = command.layer;
    var tile = command.requester;

    // TODO : support xml, gml2
    var supportedFormats = {
        json: this.getFeatures.bind(this),
        geojson: this.getFeatures.bind(this)
    };

    var func = supportedFormats[layer.format];
    if (func) {
        return func(tile, layer).then(function (result) {
            return command.resolve(result);
        });
    } else {
        return _promise2.default.reject(new Error('Unsupported mimetype ' + layer.format));
    }
};

WFS_Provider.prototype.getFeatures = function getFeatures(tile, layer) {
    var _this = this;

    if (!this.tileInsideLimit(tile, layer) || tile.material === null) {
        return _promise2.default.resolve();
    }

    var bbox = tile.bbox;
    var url = this.url(bbox, layer);
    var result = {};

    result.feature = this.cache.getRessource(url);

    if (result.feature !== undefined) {
        return _promise2.default.resolve(result);
    }
    return _Fetcher2.default.json(url).then(function (feature) {
        var crs = feature.crs || layer.crs;
        if (crs) {
            var pointOrder = _this.getPointOrder(crs);
            if (pointOrder !== undefined) {
                var features = feature.features;
                features.style = features.style || layer.style;
                if (layer.type == 'poly') {
                    result.feature = _this.featureToolBox.GeoJSON2Polygon(features, pointOrder);
                } else if (layer.type == 'bbox') {
                    // remove duplicate batiments
                    for (var i = features.length - 1; i >= 0; i--) {
                        var idBat = Number(features[i].properties.id.split('BATIMENT')[1]);
                        if (_this.batiments[idBat] === undefined) {
                            _this.batiments[idBat] = true;
                        } else {
                            features.splice(i, 1);
                        }
                    }
                    if (features.length) {
                        result.feature = _this.featureToolBox.GeoJSON2Box(features, pointOrder);
                    }
                } else if (layer.type == 'point' || layer.type == 'box') {
                    result.feature = _this.featureToolBox.GeoJSON2Point(features, bbox, layer, pointOrder);
                } else if (layer.type == 'line') {
                    result.feature = _this.featureToolBox.GeoJSON2Line(features, bbox, layer, pointOrder);
                } else {
                    return result;
                }

                if (result.feature !== undefined) {
                    // Is needed to do another request for the retail level change
                    if (result.feature.layer == null) {
                        result.feature.layer = layer;
                    }
                    _this.cache.addRessource(url, result.feature);
                }
                return result;
            }
        }
    }).catch(function () /* reason*/{
        result.feature = null;
        return result;
    });
};

WFS_Provider.prototype.getPointOrder = function getPointOrder(crs) {
    if (this.pointOrder[crs]) {
        return this.pointOrder[crs];
    }

    var pointOrder = { lat: 0, long: 1 };

    if (crs.type == 'EPSG' && crs.properties.code == '4326') {
        pointOrder.long = 0;
        pointOrder.lat = 1;
        return pointOrder;
    } else if (crs.type == 'name') {
        if (crs.properties.name) {
            var regExpEpsg = new RegExp(/^urn:[x-]?ogc:def:crs:EPSG:(\d*.?\d*)?:\d{4}/);
            if (regExpEpsg.test(crs.properties.name)) {
                return pointOrder;
            } else {
                var regExpOgc = new RegExp(/^urn:[x-]?ogc:def:crs:OGC:(\d*.?\d*)?:(CRS)?(WSG)?\d{0,2}/);
                if (regExpOgc.test(crs.properties.name)) {
                    pointOrder.long = 0;
                    pointOrder.lat = 1;
                    return pointOrder;
                }
            }
        }
    }
};

exports.default = WFS_Provider;