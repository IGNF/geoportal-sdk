'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = loadGpx;

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _Fetcher = require('./Fetcher');

var _Fetcher2 = _interopRequireDefault(_Fetcher);

var _Coordinates = require('../../Geographic/Coordinates');

var _Coordinates2 = _interopRequireDefault(_Coordinates);

var _Lines = require('../../../Renderer/Lines');

var _Lines2 = _interopRequireDefault(_Lines);

var _Points = require('../../../Renderer/Points');

var _Points2 = _interopRequireDefault(_Points);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _gpxToWayPointsArray(gpxXML) {
    return gpxXML.getElementsByTagName('wpt');
} /**
   * Generated On: 2016-07-07
   * Class: GpxUtils
   * Description: Parse Gpx file to get [lat, lon, alt]
   */

function _gGpxToWTrackPointsArray(gpxXML) {
    return gpxXML.getElementsByTagName('trkpt');
}

function _gpxPtToCartesian(pt) {
    var longitude = Number(pt.attributes.lon.nodeValue);
    var latitude = Number(pt.attributes.lat.nodeValue);
    var elevation = Number(pt.getElementsByTagName('ele')[0].childNodes[0].nodeValue);

    return new _Coordinates2.default('EPSG:4326', longitude, latitude, elevation).as('EPSG:4978').xyz();
}

function _gpxToWayPointsMesh(gpxXML) {
    var wayPts = _gpxToWayPointsArray(gpxXML);

    if (wayPts.length) {
        var colorPoint = new THREE.Color('rgb(0, 255, 0)');
        var points = new _Points2.default({
            useTexture: false,
            color: [colorPoint.r, colorPoint.g, colorPoint.b],
            opacity: 1.0
        });

        for (var i = 0; i < wayPts.length; i++) {
            if (gpxXML.center === undefined) {
                gpxXML.center = _gpxPtToCartesian(wayPts[0]);
            }
            points.addPoint(_gpxPtToCartesian(wayPts[i]).sub(gpxXML.center), colorPoint, 600.0);
        }

        points.process();

        return points;
    } else {
        return null;
    }
}

function _gpxToWTrackPointsMesh(gpxXML) {
    var trackPts = _gGpxToWTrackPointsArray(gpxXML);

    if (trackPts.length) {
        var colorLine = new THREE.Color('rgb(255, 0, 0)');
        var line = new _Lines2.default({
            linewidth: 20.0,
            useTexture: false,
            opacity: 1.0,
            sizeAttenuation: false,
            color: [colorLine.r, colorLine.g, colorLine.b]
        });

        for (var k = 0; k < trackPts.length; k++) {
            if (gpxXML.center === undefined) {
                gpxXML.center = _gpxPtToCartesian(trackPts[0]);
            }
            line.addPoint(_gpxPtToCartesian(trackPts[k]).sub(gpxXML.center));
        }

        line.process();

        return line;
    } else {
        return null;
    }
}

function _gpxToMesh(gpxXML) {
    if (!gpxXML) {
        return undefined;
    }

    var gpxMesh = new THREE.Object3D();

    // Getting the track points
    var trackPts = _gpxToWTrackPointsMesh(gpxXML);

    if (trackPts) {
        gpxMesh.add(trackPts);
    }

    // Getting the waypoint points
    var wayPts = _gpxToWayPointsMesh(gpxXML);

    if (wayPts) {
        gpxMesh.add(wayPts);
    }

    gpxMesh.matrixWorld.elements = new Float64Array(16);
    gpxMesh.matrix.elements = new Float64Array(16);
    gpxMesh.position.copy(gpxXML.center);
    gpxMesh.updateMatrixWorld();
    gpxMesh.matrixAutoUpdate = false;
    gpxMesh.matrixWorldNeedsUpdate = false;

    return gpxMesh;
}

function loadGpx(urlFile) {
    return _Fetcher2.default.xml(urlFile).then(function (gpxXML) {
        return _gpxToMesh(gpxXML);
    });
}