'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _Provider = require('./Provider');

var _Provider2 = _interopRequireDefault(_Provider);

var _BuildingBox_Provider = require('./BuildingBox_Provider');

var _BuildingBox_Provider2 = _interopRequireDefault(_BuildingBox_Provider);

var _ProjectiveTexturingMaterial = require('../../../Renderer/ProjectiveTexturingMaterial');

var _ProjectiveTexturingMaterial2 = _interopRequireDefault(_ProjectiveTexturingMaterial);

var _BasicMaterial = require('../../../Renderer/BasicMaterial');

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _PanoramicMesh = require('../../../Renderer/PanoramicMesh');

var _PanoramicMesh2 = _interopRequireDefault(_PanoramicMesh);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a provider for panoramic images/
 * Get metadata for extrinseque info and also intrinseque
 * @class Manage the panoramic provider (url, request)
 * @author alexandre devaux IGN
 * @requires ThreeJS
 *
 */

/* global Promise*/

var _options = null;
var _urlPano = '';
var _urlImage = '';
var _urlCam = '';
var _panoramicsMetaDataPromise = void 0;

function PanoramicProvider(options) {
    if (options) {
        _options = options;
        _urlPano = options.pano;
        _urlImage = options.url;
        _urlCam = options.cam;
    }
    this.panoInfo = null;
    this.geometry = null;
    this.material = null;
    this.absoluteCenter = null; // pivot in fact here, not absoluteCenter
    this.geometryRoof = null;
    this.panoramicMesh = null;
    this.projectiveTexturedMesh = null;
}

PanoramicProvider.prototype = (0, _create2.default)(_Provider2.default.prototype);
PanoramicProvider.prototype.constructor = PanoramicProvider;

PanoramicProvider.prototype.init = function init(options) {
    _urlPano = options.pano;
    _urlImage = options.url;
    _urlCam = options.cam;
};

/**
 * Return metadata info for panoramic closest to position in parameter
 * @param {type} longitude
 * @param {type} latitude
 * @param {type} distance
 * @returns {Promise}
 */
PanoramicProvider.prototype.getMetaDataFromPos = function getMetaDataFromPos(longitude, latitude) {
    var _this = this;

    if (_panoramicsMetaDataPromise == null) {
        var requestURL = _urlPano; // TODO : string_format
        _panoramicsMetaDataPromise = new _promise2.default(function (resolve, reject) {
            var req = new XMLHttpRequest();
            req.open('GET', requestURL);

            req.onload = function onloadFn() {
                if (req.status === 200) {
                    resolve(JSON.parse(req.response));
                } else {
                    reject(Error(req.statusText));
                }
            };

            req.onerror = function onerrorFn() {
                reject(Error('Network Error'));
            };

            req.send();
        });
    }
    return _panoramicsMetaDataPromise.then(function (panoramicsMetaData) {
        var indiceClosest = 0;
        var distMin = 99999;
        for (var i = 0; i < panoramicsMetaData.length; ++i) {
            var p = panoramicsMetaData[i];
            var dist = Math.sqrt((p.longitude - longitude) * (p.longitude - longitude) + (p.latitude - latitude) * (p.latitude - latitude));
            if (dist < distMin) {
                indiceClosest = i;
                distMin = dist;
            }
        }
        // FIXME: not concurrency-safe; modifying state depending on method call parameter
        _this.panoInfo = panoramicsMetaData[indiceClosest];
        return panoramicsMetaData[indiceClosest];
    });
};

PanoramicProvider.prototype.getTextureMaterial = function getTextureMaterial(panoInfo, pivot) {
    return _ProjectiveTexturingMaterial2.default.init(_options, panoInfo, pivot); // Initialize itself Ori

    // ProjectiveTexturingMaterial.createShaderMat(_options);
    // return ProjectiveTexturingMaterial.getShaderMat();
};

PanoramicProvider.prototype.updateTextureMaterial = function updateTextureMaterial(panoInfo, pivot) {
    _ProjectiveTexturingMaterial2.default.updateUniforms(panoInfo, pivot);
};

PanoramicProvider.prototype.getGeometry = function getGeometry(longitude, latitude, altitude) {
    var w = 0.003;
    var bbox = {
        minCarto: {
            longitude: longitude - w,
            latitude: latitude - w
        },
        maxCarto: {
            longitude: longitude + w,
            latitude: latitude + w
        }
    };
    // console.log(bbox);
    var options = options || {
        url: 'http://wxs.ign.fr/72hpsel8j8nhb5qgdh07gcyp/geoportail/wfs?',
        typename: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie',
        bbox: bbox,
        epsgCode: 4326
    };

    var buildingBox_Provider = new _BuildingBox_Provider2.default(options);

    return buildingBox_Provider.getData(options.bbox, altitude).then(function () {
        return {
            geometry: buildingBox_Provider.geometry,
            pivot: buildingBox_Provider.pivot,
            roof: buildingBox_Provider.geometryRoof
        };
    });
};

// Manages 3 asynchronous functions
// - Get Pano closest to lon lat (panoramic metadata)
// - Get sensors informations (camera calibration)
// - Get Building boxes from WFS
PanoramicProvider.prototype.getTextureProjectiveMesh = function getTextureProjectiveMesh(longitude, latitude, distance) {
    var _this2 = this;

    return this.getMetaDataFromPos(longitude, latitude, distance).then(function (panoInfo) {
        return _this2.getGeometry(panoInfo.longitude, panoInfo.latitude, panoInfo.altitude);
    }).then(function (data) {
        _this2.geometry = data.geometry;
        _this2.absoluteCenter = data.pivot; // pivot in fact here, not absoluteCenter
        _this2.geometryRoof = data.roof;

        return _this2.getTextureMaterial(_this2.panoInfo, _this2.absoluteCenter);
    }).then(function thenCb(shaderMaterial) {
        this.material = shaderMaterial; // new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.8});
        // this.projectiveTexturedMesh = new THREE.Mesh(this.geometry, this.material);
        this.panoramicMesh = new _PanoramicMesh2.default(this.geometry, this.material, this.absoluteCenter);
        var roofMesh = new _PanoramicMesh2.default(this.geometryRoof, new _BasicMaterial2.default(new THREE.Color(0xdddddd)), this.absoluteCenter);
        roofMesh.material.side = THREE.DoubleSide;
        roofMesh.material.transparent = true;
        roofMesh.setDisplayed(true);
        roofMesh.material.uniforms.lightingEnabled.value = false;

        this.panoramicMesh.add(roofMesh);

        // console.log(this.panoramicMesh);
        // console.log(roofMesh);
        return this.panoramicMesh;
    });
};

// Update existing panoramic mesh with new images look for the closest to parameters position
PanoramicProvider.prototype.updateMaterialImages = function updateMaterialImages(longitude, latitude, distance) {
    var _this3 = this;

    return this.getMetaDataFromPos(longitude, latitude, distance).then(function (panoInfo) {
        _this3.updateTextureMaterial(panoInfo, _this3.absoluteCenter);
        return panoInfo;
    });
};

PanoramicProvider.prototype.getUrlImageFile = function getUrlImageFile() {
    return _urlImage;
};

PanoramicProvider.prototype.getMetaDataSensorURL = function getMetaDataSensorURL() {
    return _urlCam;
};

PanoramicProvider.prototype.getMetaDataSensor = function getMetaDataSensor() {};

exports.default = PanoramicProvider;