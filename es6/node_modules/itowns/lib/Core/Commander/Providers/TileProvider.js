'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _Provider = require('./Provider');

var _Provider2 = _interopRequireDefault(_Provider);

var _Projection = require('../../Geographic/Projection');

var _Projection2 = _interopRequireDefault(_Projection);

var _BuilderEllipsoidTile = require('../../../Globe/BuilderEllipsoidTile');

var _BuilderEllipsoidTile2 = _interopRequireDefault(_BuilderEllipsoidTile);

var _TileGeometry = require('../../../Globe/TileGeometry');

var _TileGeometry2 = _interopRequireDefault(_TileGeometry);

var _OGCWebServiceHelper = require('./OGCWebServiceHelper');

var _OGCWebServiceHelper2 = _interopRequireDefault(_OGCWebServiceHelper);

var _LayeredMaterial = require('../../../Renderer/LayeredMaterial');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * A Faire
 * Les tuiles de longitude identique ont le maillage et ne demande pas 1 seule calcul pour la génération du maillage
 *
 *
 *
 *
 */

function TileProvider() {
    _Provider2.default.call(this, null);

    this.projection = new _Projection2.default();
    this.builder = new _BuilderEllipsoidTile2.default(this.projection);

    this.nNode = 0;
}

TileProvider.prototype = (0, _create2.default)(_Provider2.default.prototype);

TileProvider.prototype.constructor = TileProvider;

TileProvider.prototype.executeCommand = function executeCommand(command) {
    var bbox = command.bbox;

    var parent = command.requester;

    // build tile
    var params = {
        bbox: bbox,
        level: command.level === undefined ? parent.level + 1 : command.level,
        segment: 16,
        parentMaterial: parent.material,
        parentWmtsCoords: parent.wmtsCoords
    };

    var geometry = new _TileGeometry2.default(params, this.builder);

    var tile = new command.type(geometry, params);

    tile.setUuid(this.nNode++);
    tile.link = parent.link;
    tile.geometricError = Math.pow(2, 18 - params.level);

    parent.worldToLocal(params.center);

    tile.position.copy(params.center);
    tile.setVisibility(false);

    parent.add(tile);
    tile.updateMatrix();
    tile.updateMatrixWorld();
    tile.OBB().parent = tile; // TODO: we should use tile.add(tile.OBB())
    tile.OBB().update();

    // update bbox if node herits texture elevation from parent
    if (tile.material.getElevationLayerLevel() > _LayeredMaterial.EMPTY_TEXTURE_ZOOM) {
        var textureElevation = tile.material.getLayerTextures(_LayeredMaterial.l_ELEVATION)[0];

        var _OGCWebServiceHelper$ = _OGCWebServiceHelper2.default.ioDXBIL.computeMinMaxElevation(textureElevation.image.data, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, tile.material.offsetScale[0][0]),
            min = _OGCWebServiceHelper$.min,
            max = _OGCWebServiceHelper$.max;

        if (min && max) {
            tile.setBBoxZ(min, max);
        }
    }

    return _promise2.default.resolve(tile);
};

exports.default = TileProvider;