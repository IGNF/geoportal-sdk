'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = miniGlobe;

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function TargetMesh() {
    var ring = new THREE.RingGeometry(40, 37, 32);
    var point = new THREE.CircleGeometry(2, 32);
    var shadow = new THREE.CircleGeometry(5, 32);
    var material = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide, opacity: 0.8, transparent: true });
    var shadowMesh = new THREE.Mesh(shadow, new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, opacity: 0.5, transparent: true }));
    var targetMesh = new THREE.Mesh(ring, material);
    targetMesh.add(new THREE.Mesh(point, new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, opacity: 0.85, transparent: true })));
    targetMesh.position.set(0, 0, -500);
    targetMesh.updateMatrix();
    targetMesh.updateMatrixWorld(true);
    shadowMesh.translateZ(-10);
    targetMesh.updateMatrix();
    targetMesh.updateMatrixWorld(true);
    targetMesh.add(shadowMesh);

    return targetMesh;
}

function displayAllTilesWithLevel(globe, level) {
    globe.level0Nodes.forEach(function (node) {
        return node.traverse(function (tile) {
            if (tile.level && tile.level < level + 2) {
                tile.material.previousVisibilty = tile.material.visible;
                tile.previousVisibilty = tile.visible;
                tile.material.visible = tile.level === level;
                tile.visible = tile.level <= level;
                tile.enableRTC(false);
            }
        });
    });
}

function resetToPreviousVibility(globe, level) {
    globe.level0Nodes.forEach(function (node) {
        return node.traverse(function (tile) {
            if (tile.level && tile.level < level + 2) {
                tile.material.visible = tile.material.previousVisibilty === undefined ? tile.material.visible : tile.material.previousVisibilty;
                tile.visible = tile.previousVisibilty === undefined ? tile.visible : tile.previousVisibilty;
                tile.material.previousVisibilty = undefined;
                tile.previousVisibilty = undefined;
                tile.enableRTC(true);
            }
        });
    });
}

function miniGlobe(view, globe) {
    var miniGlobe = {};

    var miniGlobeCamera = view.camera.camera3D.clone();
    miniGlobeCamera.aspect = 1.0;
    miniGlobeCamera.updateProjectionMatrix();
    miniGlobeCamera.maxDistance = miniGlobeCamera.position.length();

    var targetMesh = TargetMesh();
    miniGlobeCamera.add(targetMesh);
    view.scene.add(miniGlobeCamera);

    miniGlobe.render = function (renderer) {
        if (view.miniGlobeOptions.visible) {
            displayAllTilesWithLevel(globe, 2);
            var distanceCamera = view.camera.camera3D.position.length();
            var distance = Math.min(miniGlobeCamera.maxDistance, distanceCamera * 1.5);
            miniGlobeCamera.position.copy(view.controls.moveTarget()).setLength(distance);
            miniGlobeCamera.lookAt(view.controls.moveTarget());
            miniGlobeCamera.up.set(0, 0, 1);
            miniGlobeCamera.updateMatrix();
            miniGlobeCamera.updateMatrixWorld(true);
            targetMesh.visible = false;
            renderer.clearDepth();
            renderer.setViewport(view.miniGlobeOptions.position.x, view.miniGlobeOptions.position.y, view.miniGlobeOptions.size, view.miniGlobeOptions.size);
            renderer.render(view.scene, miniGlobeCamera);
            miniGlobeCamera.position.set(0, 0, 0);
            miniGlobeCamera.updateMatrix();
            miniGlobeCamera.updateMatrixWorld(true);
            renderer.clearDepth();
            targetMesh.visible = true;
            renderer.render(view.scene, miniGlobeCamera);
            resetToPreviousVibility(globe, 2);
        }
    };

    return miniGlobe;
}