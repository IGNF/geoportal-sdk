'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = MiniGlobe;

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _GlobeView = require('../GlobeView');

var _View = require('../../View');

var _View2 = _interopRequireDefault(_View);

var _SubdivisionControl = require('../../../Process/SubdivisionControl');

var _SubdivisionControl2 = _interopRequireDefault(_SubdivisionControl);

var _GlobeTileProcessing = require('../../../Process/GlobeTileProcessing');

var _TiledNodeProcessing = require('../../../Process/TiledNodeProcessing');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function TargetMesh(layer) {
    var ring = new THREE.RingGeometry(40, 37, 32);
    var point = new THREE.CircleGeometry(2, 32);
    var shadow = new THREE.CircleGeometry(5, 32);
    var material = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide, opacity: 0.8, transparent: true });
    var shadowMesh = new THREE.Mesh(shadow, new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, opacity: 0.5, transparent: true }));
    var targetMesh = new THREE.Mesh(ring, material);
    var pointMesh = new THREE.Mesh(point, new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, opacity: 0.85, transparent: true }));
    targetMesh.add(pointMesh);
    targetMesh.position.set(0, 0, -500);
    shadowMesh.translateZ(-10);
    targetMesh.add(shadowMesh);
    targetMesh.layers.set(layer);
    shadowMesh.layers.set(layer);
    pointMesh.layers.set(layer);

    return targetMesh;
}

function MiniGlobe(view, globe, options) {
    var camera = view.camera.camera3D.clone();
    camera.aspect = 1.0;
    camera.updateProjectionMatrix();
    camera.minDistance = 10000000;
    camera.maxDistance = 30000000;

    view.scene.add(camera);

    var root = new THREE.Object3D();
    view.scene.add(root);

    function subdivision(context, layer, node) {
        if (_SubdivisionControl2.default.hasEnoughTexturesToSubdivide(context, layer, node)) {
            return (0, _GlobeTileProcessing.globeSubdivisionControl)(2, 2, 1.0)(context, layer, node);
        }
        return false;
    }

    var miniGlobeLayer = (0, _GlobeView.createGlobeLayer)('miniGlobe', {
        object3d: root,
        maxSubdivisionLevel: 2
    });

    miniGlobeLayer.update = (0, _TiledNodeProcessing.processTiledGeometryNode)(function () {
        return false;
    }, subdivision);

    _View2.default.prototype.addLayer.call(view, miniGlobeLayer);

    camera.layers.disable(globe.threejsLayer);
    camera.layers.enable(miniGlobeLayer.threejsLayer);
    view.camera.camera3D.layers.disable(miniGlobeLayer.threejsLayer);

    camera.add(TargetMesh(miniGlobeLayer.threejsLayer));

    miniGlobeLayer.options = options;

    miniGlobeLayer.render = function (renderer) {
        if (miniGlobeLayer.options.visible && view.controls) {
            var distanceCamera = view.camera.camera3D.position.length();
            var distance = Math.min(Math.max(distanceCamera * 1.5, camera.minDistance), camera.maxDistance);
            camera.position.copy(view.controls.moveTarget()).setLength(distance);
            camera.lookAt(view.controls.moveTarget());
            camera.up.set(0, 0, 1);
            camera.updateMatrixWorld();
            renderer.clearDepth();
            renderer.setViewport(miniGlobeLayer.options.position.x, view.mainLoop.gfxEngine.getWindowSize().y - miniGlobeLayer.options.position.y - miniGlobeLayer.options.size, miniGlobeLayer.options.size, miniGlobeLayer.options.size);
            renderer.render(view.scene, camera);
        }
    };

    return miniGlobeLayer;
}