'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _stringFormat = require('string-format');

var _stringFormat2 = _interopRequireDefault(_stringFormat);

var _Extent = require('../../Geographic/Extent');

var _Extent2 = _interopRequireDefault(_Extent);

var _Coordinates = require('../../Geographic/Coordinates');

var _Coordinates2 = _interopRequireDefault(_Coordinates);

var _Provider = require('./Provider');

var _Provider2 = _interopRequireDefault(_Provider);

var _Fetcher = require('./Fetcher');

var _Fetcher2 = _interopRequireDefault(_Fetcher);

var _CacheRessource = require('./CacheRessource');

var _CacheRessource2 = _interopRequireDefault(_CacheRessource);

var _TileMesh = require('../../TileMesh');

var _TileMesh2 = _interopRequireDefault(_TileMesh);

var _ProjectiveTextureVS = "#ifdef GL_ES\n    precision  highp float;\n#endif\n\n#ifdef USE_LOGDEPTHBUF\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n        varying float vFragDepth;\n    #endif\n    uniform float logDepthBufFC;\n#endif\n\nuniform mat4 mvpp[N];\nvarying vec4 texcoord[N];\nvec4 posView;\n\nvoid main() {\n    posView =  modelViewMatrix * vec4(position,1.);\n    for(int i=0; i<N; ++i) texcoord[i] = mvpp[i] * posView;\n    gl_Position = projectionMatrix * posView;\n#ifdef USE_LOGDEPTHBUF\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n    #ifdef USE_LOGDEPTHBUF_EXT\n        vFragDepth = 1.0 + gl_Position.w;\n    #else\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n    #endif\n#endif\n}\n";

var _ProjectiveTextureVS2 = _interopRequireDefault(_ProjectiveTextureVS);

var _ProjectiveTextureFS = "#ifdef GL_ES\n    precision  highp float;\n#endif\n#ifdef USE_LOGDEPTHBUF\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n        varying float vFragDepth;\n    #endif\n    uniform float logDepthBufFC;\n#endif\n\nvarying vec4 texcoord[N];\nuniform sampler2D texture[N];\nuniform vec2      size[N];\n\n#ifdef WITH_DISTORT\nuniform vec2      pps[N];\nuniform vec4      distortion[N];\nuniform vec3      l1l2[N];\n#endif\nconst float borderfadeoutinv = 0.02;\nfloat getUV(inout vec2 p, vec2 s)\n{\n   p.y = s.y-p.y;\n   vec2 d = min(p.xy,s-p.xy);\n   p/=s;\n   return min(d.x,d.y);\n}\n#ifdef WITH_DISTORT\nvoid distort(inout vec2 p, vec4 adist, vec2 apps)\n{\n   vec2 v = p - apps;\n   float v2 = dot(v,v);\n   if(v2>adist.w) p = vec2(-1.);\n   else p += (v2*(adist.x+v2*(adist.y+v2*adist.z)))*v;\n}\nvoid distort(inout vec2 p, vec4 dist, vec3 l1l2, vec2 pps)\n{ \n   if ((l1l2.x == 0.)&&(l1l2.y == 0.)) distort(p,dist,pps);\n   else {\n   vec2 AB = 1./l1l2.z*(p-pps);\n   float R = sqrt(dot(AB,AB));\n   float lambda = atan(R)/R;\n   vec2 ab = lambda*AB;\n   float rho2 = dot(ab,ab);\n   float r357 = (1. + rho2* (dist.x + rho2* (dist.y + rho2*dist.z)))*l1l2.z;\n   p = pps + r357*ab + vec2((l1l2.x*ab.x+l1l2.y*ab.y)*l1l2.z,l1l2.y*ab.x*l1l2.z);\n   }\n}\n\n#endif\nvoid main(void)\n{\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif\n    vec4 color  = vec4(0.);\n    vec2 p;\n    vec4 c;\n    float d;\n    int blend = 0;\n";

var _ProjectiveTextureFS2 = _interopRequireDefault(_ProjectiveTextureFS);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Generated On: 2017-12-09
 * Class: OrientedImage_Provider
 * Description: Provides Oriented Image data for immersive navigation
 */
function OrientedImage_Provider() {
    this.cache = (0, _CacheRessource2.default)();
}

OrientedImage_Provider.prototype = (0, _create2.default)(_Provider2.default.prototype);

OrientedImage_Provider.prototype.constructor = OrientedImage_Provider;

OrientedImage_Provider.prototype.preprocessDataLayer = function (layer) {
    layer.format = layer.options.mimetype || 'json';
    layer.offset = layer.offset || { x: 0, y: 0, z: 0 };
    layer.orientedImages = null;
    layer.currentPano = -1;
    layer.currentMat = null;
    layer.sensors = [];
    layer.networkOptions = { crossOrigin: '' };
    if (!(layer.extent instanceof _Extent2.default)) {
        layer.extent = new _Extent2.default(layer.projection, layer.extent);
    }
    var promises = [];

    // layer.orientations: a JSON file with position/orientation for all the oriented images
    promises.push(_Fetcher2.default.json(layer.orientations, layer.networkOptions));
    // layer.calibrations: a JSON file with calibration for all cameras
    // it's possible to have more than one camera (ex: ladybug images with 6 cameras)
    promises.push(_Fetcher2.default.json(layer.calibrations, layer.networkOptions));

    return _promise2.default.all(promises).then(function (res) {
        orientedImagesInit(res[0], layer);sensorsInit(res[1], layer);
    });
};

// initialize a 3D position for each image (including offset or CRS projection if necessary)
function orientedImagesInit(res, layer) {
    layer.orientedImages = res;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(layer.orientedImages), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var ori = _step.value;

            ori.easting += layer.offset.x;
            ori.northing += layer.offset.y;
            ori.altitude += layer.offset.z;
            if (layer.projection == 'EPSG:4978') {
                ori.coordinates = new _Coordinates2.default('EPSG:4978', ori.easting, ori.northing, ori.altitude);
            } else if (layer.projection == 'EPSG:4326') {
                ori.coordinates = new _Coordinates2.default('EPSG:4326', ori.easting, ori.northing, ori.altitude).as('EPSG:4978');
            } else {
                ori.coordinates = new _Coordinates2.default(layer.projection, ori.easting, ori.northing, ori.altitude).as('EPSG:4326').as('EPSG:4978');
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

// initialize a sensor for each camera and create the material (and the shader)
function sensorsInit(res, layer) {
    var i = void 0;

    var withDistort = false;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = (0, _getIterator3.default)(res), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var s = _step2.value;

            var sensor = {};
            sensor.id = s.id;

            var rotCamera2Pano = new THREE.Matrix3().fromArray(s.rotation);
            var rotTerrain = new THREE.Matrix3().set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            if (layer.orientationType && layer.orientationType == 'Stereopolis2') {
                rotTerrain = new THREE.Matrix3().set(0, -1, 0, 1, 0, 0, 0, 0, 1);
            }
            var rotEspaceImage = new THREE.Matrix3().set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            rotCamera2Pano = rotTerrain.clone().multiply(rotCamera2Pano.clone().multiply(rotEspaceImage));
            var rotPano2Camera = rotCamera2Pano.clone().transpose();

            var centerCameraInPano = new THREE.Vector3().fromArray(s.position);
            var transPano2Camera = new THREE.Matrix4().makeTranslation(-centerCameraInPano.x, -centerCameraInPano.y, -centerCameraInPano.z);
            var projection = new THREE.Matrix3().fromArray(s.projection).transpose();
            var rotPano2Texture = projection.clone().multiply(rotPano2Camera);
            sensor.mp2t = getMatrix4FromRotation(rotPano2Texture).multiply(transPano2Camera);
            // sensor.rotPano2Texture = rotPano2Texture;
            // sensor.centerCameraInPano = centerCameraInPano;
            sensor.distortion = null;
            sensor.pps = null;
            if (s.distortion) {
                sensor.pps = new THREE.Vector2().fromArray(s.distortion.pps);
                var disto = new THREE.Vector3().fromArray(s.distortion.poly357);
                sensor.distortion = new THREE.Vector4(disto.x, disto.y, disto.z, s.distortion.limit * s.distortion.limit);
                if (s.distortion.l1l2) {
                    sensor.l1l2 = new THREE.Vector2().fromArray(s.distortion.l1l2);
                    sensor.etats = s.distortion.etats;
                } else {
                    sensor.l1l2 = new THREE.Vector2().set(0, 0);
                    sensor.etats = 0;
                }
                withDistort = true;
            }
            sensor.size = new THREE.Vector2().fromArray(s.size);
            layer.sensors.push(sensor);
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    (function () {
        var U = {
            size: { type: 'v2v', value: [] },
            mvpp: { type: 'm4v', value: [] },
            texture: { type: 'tv', value: [] }
        };
        if (withDistort) {
            U.distortion = { type: 'v4v', value: [] };
            U.pps = { type: 'v2v', value: [] };
            U.l1l2 = { type: 'v3v', value: [] };
        }
        for (i = 0; i < layer.sensors.length; ++i) {
            U.size.value[i] = layer.sensors[i].size;
            U.mvpp.value[i] = new THREE.Matrix4();
            U.texture.value[i] = new THREE.Texture();
            if (withDistort) {
                U.distortion.value[i] = layer.sensors[i].distortion;
                U.pps.value[i] = layer.sensors[i].pps;
                U.l1l2.value[i] = new THREE.Vector3().set(layer.sensors[i].l1l2.x, layer.sensors[i].l1l2.y, layer.sensors[i].etats);
            }
        }
        var projectiveTextureFS = '#define N ' + layer.sensors.length + '\n';
        projectiveTextureFS += withDistort ? '#define WITH_DISTORT\n' : '';
        projectiveTextureFS += _ProjectiveTextureFS2.default;
        for (i = 0; i < layer.sensors.length; ++i) {
            projectiveTextureFS += 'if(texcoord[' + i + '].z>0.) {\n            p =  texcoord[' + i + '].xy/texcoord[' + i + '].z;\n            #ifdef WITH_DISTORT\n              distort(p,distortion[' + i + '],l1l2[' + i + '],pps[' + i + ']);\n            #endif\n               d = borderfadeoutinv * getUV(p,size[' + i + ']);\n               if(d>0.) {\n                   c = d*texture2D(texture[' + i + '],p);\n                   color += c;\n                   if(c.a>0.) ++blend;\n               }\n            }\n';
        }
        projectiveTextureFS += '   if (color.a > 0.0) color = color / color.a;\n' + '   color.a = 1.;\n' + '   gl_FragColor = color;\n' + '} \n';
        // create the shader material for Three
        layer.shaderMat = new THREE.ShaderMaterial({
            uniforms: U,
            vertexShader: '#define N ' + layer.sensors.length + '\n ' + _ProjectiveTextureVS2.default,
            fragmentShader: projectiveTextureFS,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.1
        });
    })();

    function getMatrix4FromRotation(Rot) {
        var M4 = new THREE.Matrix4();
        M4.elements[0] = Rot.elements[0];
        M4.elements[1] = Rot.elements[1];
        M4.elements[2] = Rot.elements[2];
        M4.elements[4] = Rot.elements[3];
        M4.elements[5] = Rot.elements[4];
        M4.elements[6] = Rot.elements[5];
        M4.elements[8] = Rot.elements[6];
        M4.elements[9] = Rot.elements[7];
        M4.elements[10] = Rot.elements[8];
        return M4;
    }
}

OrientedImage_Provider.prototype.tileInsideLimit = function (tile, layer) {
    return (layer.level === undefined || tile.level === layer.level) && layer.extent.intersect(tile.extent);
};

// request textures for an oriented image
function loadOrientedImageData(layer, command) {
    var minIndice = command.requester;
    if (minIndice != layer.currentPano) {
        // console.log('OrientedImage Provider cancel texture loading');
        return _promise2.default.resolve();
    }
    var oiInfo = layer.orientedImages[minIndice];
    var promises = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        var _loop = function () {
            var sensor = _step3.value;
            url = (0, _stringFormat2.default)(layer.images, { imageId: oiInfo.id, sensorId: sensor.id });

            var _Fetcher$texture = _Fetcher2.default.texture(url, layer.networkOptions),
                texture = _Fetcher$texture.texture,
                promise = _Fetcher$texture.promise;

            promise.then(function () {
                return texture;
            });
            promises.push(promise);
        };

        for (var _iterator3 = (0, _getIterator3.default)(layer.sensors), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var url;

            _loop();
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    return _promise2.default.all(promises);
}

OrientedImage_Provider.prototype.executeCommand = function (command) {
    var layer = command.layer;
    var tile = command.requester;
    var destinationCrs = command.view.referenceCrs;
    // position of pano
    if (command.requester instanceof _TileMesh2.default) {
        return this.getFeatures(destinationCrs, tile, layer, command).then(function (result) {
            return command.resolve(result);
        });
    } else {
        // texture of pano
        return loadOrientedImageData(layer, command).then(function (result) {
            return command.resolve(result);
        });
    }
};

function assignLayer(object, layer) {
    if (object) {
        object.layer = layer.id;
        object.layers.set(layer.threejsLayer);
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = (0, _getIterator3.default)(object.children), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var c = _step4.value;

                assignLayer(c, layer);
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }

        return object;
    }
}

function applyColor(colorAttribute, indice) {
    switch (indice / 3 % 4) {
        case 0:
            colorAttribute[indice] = 0;
            colorAttribute[indice + 1] = 255;
            colorAttribute[indice + 2] = 0;
            break;
        case 1:
            colorAttribute[indice] = 255;
            colorAttribute[indice + 1] = 255;
            colorAttribute[indice + 2] = 0;
            break;
        case 2:
            colorAttribute[indice] = 255;
            colorAttribute[indice + 1] = 0;
            colorAttribute[indice + 2] = 0;
            break;
        case 3:
            colorAttribute[indice] = 0;
            colorAttribute[indice + 1] = 0;
            colorAttribute[indice + 2] = 0;
            break;
        default:
            break;
    }
}

// load data for a layer/tile/crs
OrientedImage_Provider.prototype.getFeatures = function (crs, tile, layer) {
    if (layer.orientedImages && layer.orientedImages.length > 0) {
        var sel = [];
        var prop = [];
        var indicePano = [];
        var i = 0;
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = (0, _getIterator3.default)(layer.orientedImages), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var ori = _step5.value;

                var coordinates = ori.coordinates;
                if (tile.extent.isPointInside(coordinates)) {
                    sel.push([coordinates._values[0], coordinates._values[1], coordinates._values[2]]);
                    prop.push(ori);
                    indicePano.push(i);
                }
                ++i;
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        if (sel.length) {
            // create THREE.Points with the orientedImage position
            var vertices = new Float32Array(3 * sel.length);
            var colorAttribute = new Uint8Array(sel.length * 3);
            var indice = 0;
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
                for (var _iterator6 = (0, _getIterator3.default)(sel), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                    var v = _step6.value;

                    vertices[indice] = v[0] - sel[0][0];
                    vertices[indice + 1] = v[1] - sel[0][1];
                    vertices[indice + 2] = v[2] - sel[0][2];

                    applyColor(colorAttribute, indice);
                    indice += 3;
                }
            } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                    }
                } finally {
                    if (_didIteratorError6) {
                        throw _iteratorError6;
                    }
                }
            }

            var bufferGeometry = new THREE.BufferGeometry();
            bufferGeometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
            bufferGeometry.addAttribute('color', new THREE.BufferAttribute(colorAttribute, 3, true));
            var P = new THREE.Points(bufferGeometry);

            P.material.vertexColors = THREE.VertexColors;
            P.material.color = new THREE.Color(0xffffff);
            P.material.size = 5;
            P.material.sizeAttenuation = false;
            P.opacity = 0.5;
            P.transparent = true;

            P.position.set(sel[0][0], sel[0][1], sel[0][2]);
            P.updateMatrixWorld(true);
            return _promise2.default.resolve(assignLayer(P, layer));
        }
    }
    return _promise2.default.resolve();
};

exports.default = OrientedImage_Provider;