'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _pbf = require('pbf');

var _pbf2 = _interopRequireDefault(_pbf);

var _vectorTile = require('@mapbox/vector-tile');

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _Fetcher = require('./Fetcher');

var _Fetcher2 = _interopRequireDefault(_Fetcher);

var _CacheRessource = require('./CacheRessource');

var _CacheRessource2 = _interopRequireDefault(_CacheRessource);

var _GeoJSON2Features = require('../../../Renderer/ThreeExtended/GeoJSON2Features');

var _GeoJSON2Features2 = _interopRequireDefault(_GeoJSON2Features);

var _Feature2Texture = require('../../../Renderer/ThreeExtended/Feature2Texture');

var _Feature2Texture2 = _interopRequireDefault(_Feature2Texture);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cache = (0, _CacheRessource2.default)();
var cachePending = new _map2.default();

function assignLayer(object, layer) {
    if (object) {
        object.layer = layer.id;
        object.layers.set(layer.threejsLayer);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = (0, _getIterator3.default)(object.children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var c = _step.value;

                assignLayer(c, layer);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return object;
    }
}

/**
 * Fetch a vector tile, and return it as VectorTile in a Promise.
 *
 * @param {string} url - the url to fetch from
 * @param {Object=} networkOptions - fetch options (passed directly to fetch)
 *
 * @return {Promise}
 */
var getVectorTileRawByURL = function (url, networkOptions) {
    var textureCache = cache.getRessource(url);

    if (textureCache !== undefined) {
        return _promise2.default.resolve(textureCache);
    }

    var pending = cachePending.get(url);
    if (pending) {
        return pending;
    }

    var promise = cachePending.has(url) ? cachePending.get(url) : _Fetcher2.default.arrayBuffer(url, networkOptions);

    cachePending.set(url, promise);

    return promise.then(function (buffer) {
        return new _vectorTile.VectorTile(new _pbf2.default(buffer));
    });
};

/**
 * Fetch and return a valid GeoJSON, parsed from a VectorTile.
 *
 * @param {string} url - the url to fetch from
 * @param {TileMesh} tile
 * @param {Layer} layer
 * @param {Extent} coords - the coordinates for the layer
 *
 * @return {Promise}
 */
var getVectorTileGeoJSONByUrl = function (url, tile, layer, coords) {
    return getVectorTileRawByURL(url, layer.networkOptions).then(function (vector_tile) {
        var layers = (0, _keys2.default)(vector_tile.layers);

        if (layers.length < 1) return;

        // We need to create a featureCollection as VectorTile does no support it
        var geojson = {
            type: 'FeatureCollection',
            features: [],
            crs: { type: 'EPSG', properties: { code: 4326 } },
            extent: tile.extent
        };

        layers.forEach(function (layer_id) {
            var l = vector_tile.layers[layer_id];

            for (var i = 0; i < l.length; i++) {
                var feature = void 0;
                // We need to move from TMS to Google/Bing/OSM coordinates
                // https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates/
                // Only if the layer.origin is top
                if (layer.origin == 'top') {
                    feature = l.feature(i).toGeoJSON(coords.col, coords.row, coords.zoom);
                } else {
                    var y = 1 << coords.zoom;
                    feature = l.feature(i).toGeoJSON(coords.col, y - coords.row - 1, coords.zoom);
                }
                if (layers.length > 1) {
                    feature.properties.vt_layer = layer_id;
                }

                geojson.features.push(feature);
            }
        });

        return geojson;
    });
};

/**
 * Fetch and return an object containing a THREE.Texture, that can be used
 * directly in a tile. By default, the result is similar to the Raster_Provider.
 *
 * @param {string} url - the url to fetch from
 * @param {TileMesh} tile
 * @param {Layer} layer
 * @param {Extent} coords - the coordinates for the layer
 *
 * @return {Promise}
 */
var getVectorTileTextureByUrl = function (url, tile, layer, coords) {
    if (layer.type !== 'color') return;

    return getVectorTileGeoJSONByUrl(url, tile, layer, coords).then(function (geojson) {
        if (!geojson) return;

        var features = _GeoJSON2Features2.default.parse(tile.extent.crs(), geojson, layer.extent, { filter: layer.filter, buildExtent: true });

        // sort features before drawing
        if (layer.sort) {
            features.features.sort(layer.sort);
        }

        var colorCoords = tile.extent.as(layer.projection);
        var result = { pitch: new THREE.Vector4(0, 0, 1, 1) };
        result.texture = _Feature2Texture2.default.createTextureFromFeature(features, tile.extent, 256, layer.style);
        result.texture.extent = tile.extent;
        result.texture.coords = colorCoords;
        result.texture.coords.zoom = tile.level;

        if (layer.transparent) {
            result.texture.premultiplyAlpha = true;
        }

        return result;
    });
};

/**
 * Fetch and return an object containing Meshes, that can be added to the scene.
 *
 * @param {string} url - the url to fetch from
 * @param {TileMesh} tile
 * @param {Layer} layer
 * @param {Extent} coords - the coordinates for the layer
 *
 * @return {Promise}
 */
var getVectorTileMeshByUrl = function (url, tile, layer, coords) {
    if (layer.type !== 'geometry') return;

    return getVectorTileGeoJSONByUrl(url, tile, layer, coords).then(function (geojson) {
        if (!geojson) return;

        var features = _GeoJSON2Features2.default.parse(tile.extent.crs(), geojson, layer.extent, { filter: layer.filter, buildExtent: true });

        // We assume that the user has specified the convert method
        return assignLayer(layer.convert(features), layer);
    });
};

exports.default = {
    getVectorTileRawByURL: getVectorTileRawByURL,
    getVectorTileGeoJSONByUrl: getVectorTileGeoJSONByUrl,
    getVectorTileTextureByUrl: getVectorTileTextureByUrl,
    getVectorTileMeshByUrl: getVectorTileMeshByUrl
};