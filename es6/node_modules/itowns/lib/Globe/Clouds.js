'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _NodeMesh = require('../Renderer/NodeMesh');

var _NodeMesh2 = _interopRequireDefault(_NodeMesh);

var _WMS_Provider = require('../Core/Commander/Providers/WMS_Provider');

var _WMS_Provider2 = _interopRequireDefault(_WMS_Provider);

var _CloudsFS = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\nuniform vec3 lightPosition;\nuniform sampler2D diffuse;\nuniform float time;\nuniform bool lightingEnabled;\nvarying vec2  vUv;\nvarying vec3 pos;\nvarying vec3 vNormal;\n\nfloat speed = 0.01;\nfloat noiseScale = 0.005;\n\nvoid main()\n{\n     #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    // Correct Y knowing image is -85 85\n    vec2 vUv2 = vec2(vUv.x, clamp(vUv.y + (vUv.y - 0.5) * - 0.45, 0., 1.));\n    float coefDistCam = (length(cameraPosition.xyz) - 6400000.) / 500000.;\n\n    vec2 uvTime =  vUv2 + vec2( -0.1, .1 ) * mod(time * speed, 1.);\n    vec4 noiseColor = texture2D( diffuse, uvTime );\n    vec2 uvNoise = vUv2 + noiseScale * vUv2 * vec2(noiseColor.r, noiseColor.b );\n\n    vec4 color = texture2D( diffuse, uvNoise); //texture2D( diffuse, vUv2 );\n    float l = (max(color.r,max(color.g,color.b)) + min(color.r,min(color.g,color.b))) / 2.;\n    l *= l*1.5;\n    gl_FragColor =  0.25 +  (texture2D( diffuse, vUv2 ) * 0.95);\n    gl_FragColor.b += 0.1;\n\n    gl_FragColor.a = min(time * min( coefDistCam, 1.2) , 1.) * (vUv.y <= 0.75 ? l : (1. - ((vUv.y - 0.75) / 0.25)) * l  );\n\n    if(lightingEnabled){   // Add lighting\n        float light = min(2. * dot(vNormal, lightPosition),1.); //normalize(pos.xyz)\n        gl_FragColor.a *= -light;\n    }\n}";

var _CloudsFS2 = _interopRequireDefault(_CloudsFS);

var _CloudsVS = "\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n#define EPSILON 1e-6\n\nuniform vec3  lightPosition;\nvarying vec2  vUv;\nvarying vec3 vNormal;\nvarying vec3 pos;\nvec3 normalES;\nvec3 normalCAMES;\n\n\nvoid main()\n{\n\n    vUv = uv;\n    vNormal = normal;\n    pos = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n\n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n\n}\n\n\n";

var _CloudsVS2 = _interopRequireDefault(_CloudsVS);

var _Atmosphere = require('./Atmosphere');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

function Clouds() /* size*/{
    _NodeMesh2.default.call(this);

    this.providerWMS = new _WMS_Provider2.default({});
    this.loader = new THREE.TextureLoader();
    this.loader.crossOrigin = '';
    this.live = false;
    this.satelliteAnimation = true;
    this.texture = null;
    this.geometry = new THREE.SphereGeometry(6400000, 96, 96);

    this.uniforms = {
        diffuse: {
            type: 't',
            value: new THREE.Texture() // this.loader.load("http://realearth.ssec.wisc.edu/api/image?products=globalir&bounds=-85,-178,85,178&width=256&height=128")
        },
        time: {
            type: 'f',
            value: 0.0
        },
        lightingEnabled: { value: false },
        lightPosition: {
            type: 'v3',
            value: _Atmosphere.LIGHTING_POSITION.clone().normalize()
        }
    };

    this.material = new THREE.ShaderMaterial({

        uniforms: this.uniforms,
        vertexShader: _CloudsVS2.default,
        fragmentShader: _CloudsFS2.default,
        //   blending        : THREE.AdditiveBlending,
        transparent: true,
        wireframe: false

    });

    this.rotation.y += Math.PI;

    // this.generate();

    this.visible = false;
}

Clouds.prototype = (0, _create2.default)(_NodeMesh2.default.prototype);
Clouds.prototype.constructor = Clouds;

Clouds.prototype.generate = function generate(satelliteAnimation) {
    var _this = this;

    this.satelliteAnimation = satelliteAnimation;
    if (!satelliteAnimation) {
        this.live = true;
        var coWMS = {
            latBound: new THREE.Vector2(-85, 85),
            longBound: new THREE.Vector2(-178, 178),
            width: 2048,
            height: 1024
        };

        var url = this.providerWMS.urlGlobalIR(coWMS, 0);
        this.loader.load(url, function (texture) {
            _this.material.blending = THREE.NormalBlending;
            _this.material.uniforms.diffuse.value = texture;
            _this.material.uniforms.diffuse.needsUpdate = true;
            _this.animate();
        });
    } else {
        this.live = true;
        var video = document.getElementById('video');

        this.texture = new THREE.VideoTexture(video);
        this.texture.minFilter = THREE.LinearFilter;
        this.texture.magFilter = THREE.LinearFilter;
        this.texture.format = THREE.RGBFormat;

        // this.material = new THREE.MeshBasicMaterial( { color: 0xffffff, map: this.texture});//, transparent : true, opacity:0.8});
        this.material.blending = THREE.AdditiveBlending;
        this.material.uniforms.diffuse.value = this.texture;
        this.material.uniforms.diffuse.needsUpdate = true;
        this.animate();
    }
};

Clouds.prototype.animate = function animate() {
    if (!this.satelliteAnimation) this.material.uniforms.time.value += 0.01;
    requestAnimationFrame(this.animate.bind(this));
};

Clouds.prototype.setLightingOn = function setLightingOn(enable) {
    this.material.uniforms.lightingEnabled.value = enable;
};

Clouds.prototype.updateLightingPos = function updateLightingPos(pos) {
    this.material.uniforms.lightPosition.value = pos.clone().normalize();
};

exports.default = Clouds;