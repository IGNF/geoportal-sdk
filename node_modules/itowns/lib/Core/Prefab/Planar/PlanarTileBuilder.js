"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var THREE = _interopRequireWildcard(require("three"));

var _OBB2 = _interopRequireDefault(require("../../../Renderer/OBB"));

var _Coordinates = _interopRequireDefault(require("../../Geographic/Coordinates"));

var _Extent = _interopRequireDefault(require("../../Geographic/Extent"));

var quaternion = new THREE.Quaternion();

var _center = new THREE.Vector3();

var PlanarTileBuilder =
/*#__PURE__*/
function () {
  function PlanarTileBuilder() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, PlanarTileBuilder);

    if (options.projection) {
      this.projection = options.projection;
    } else {
      throw new Error('options.projection is mandatory for PlanarTileBuilder');
    }

    this.tmp = {
      coords: new _Coordinates["default"]('EPSG:4326', 0, 0),
      position: new THREE.Vector3(),
      normal: new THREE.Vector3(0, 0, 1)
    };
    this.uvCount = options.uvCount || 1;
  } // prepare params
  // init projected object -> params.projected


  (0, _createClass2["default"])(PlanarTileBuilder, [{
    key: "prepare",
    value: function prepare(params) {
      params.nbRow = Math.pow(2, params.zoom + 1.0);
      params.projected = new THREE.Vector3();
    } // get center tile in cartesian 3D

  }, {
    key: "center",
    value: function center(extent) {
      extent.center(this.tmp.coords);

      _center.set(this.tmp.coords.x, this.tmp.coords.y, 0);

      return _center;
    } // get position 3D cartesian

  }, {
    key: "vertexPosition",
    value: function vertexPosition(params) {
      this.tmp.position.set(params.projected.x, params.projected.y, 0);
      return this.tmp.position;
    } // get normal for last vertex

  }, {
    key: "vertexNormal",
    value: function vertexNormal() {
      return this.tmp.normal;
    } // coord u tile to projected

  }, {
    key: "uProjecte",
    value: function uProjecte(u, params) {
      params.projected.x = params.extent.west + u * (params.extent.east - params.extent.west);
    } // coord v tile to projected

  }, {
    key: "vProjecte",
    value: function vProjecte(v, params) {
      params.projected.y = params.extent.south + v * (params.extent.north - params.extent.south);
    } // get oriented bounding box of tile

  }, {
    key: "OBB",
    value: function OBB(boundingBox) {
      return new _OBB2["default"](boundingBox.min, boundingBox.max);
    }
  }, {
    key: "computeSharableExtent",
    value: function computeSharableExtent(extent) {
      // compute sharable extent to pool the geometries
      // the geometry in common extent is identical to the existing input
      // with a translation
      var sharableExtent = new _Extent["default"](extent.crs, 0, Math.abs(extent.west - extent.east), 0, Math.abs(extent.north - extent.south));
      return {
        sharableExtent: sharableExtent,
        quaternion: quaternion,
        position: this.center(extent).clone()
      };
    }
  }]);
  return PlanarTileBuilder;
}();

var _default = PlanarTileBuilder;
exports["default"] = _default;